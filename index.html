<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Digital Soul Mirror</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; user-select: none; }
    
    #container { position: absolute; width: 100%; height: 100%; top: 0; left: 0; z-index: 0; }
    
    /* UI ë ˆì´ì–´ */
    #ui-layer {
      position: absolute; bottom: 0; left: 0; width: 100%; height: 100%;
      pointer-events: none; z-index: 10;
      display: flex; flex-direction: column; justify-content: flex-end; align-items: center;
      padding-bottom: 40px;
    }
    
    #info {
      position: absolute; top: 30px; width: 100%;
      color: rgba(255,255,255,0.6); font-size: 14px; text-align: center;
      text-shadow: 0 0 5px rgba(0,0,0,0.8); letter-spacing: 1px;
    }

    /* 1. ì¹´ë©”ë¼ ë¯¸ë¦¬ë³´ê¸° ì°½ (ì›í˜•) */
    #camera-frame {
      width: 120px; height: 120px;
      border-radius: 50%;
      border: 2px solid rgba(255, 255, 255, 0.2);
      background: #000;
      overflow: hidden;
      margin-bottom: 20px;
      box-shadow: 0 0 20px rgba(0,0,0,0.5);
      position: relative;
      pointer-events: auto; /* í„°ì¹˜ ê°€ëŠ¥ */
    }
    
    #cam {
      width: 100%; height: 100%;
      object-fit: cover;
      transform: scaleX(-1); /* ê±°ìš¸ëª¨ë“œ */
      opacity: 0.8;
    }

    /* ìŠ¤ìº” ë¼ì¸ íš¨ê³¼ (ì¹´ë©”ë¼ ìœ„) */
    #scan-line {
      position: absolute; top: 0; left: 0; width: 100%; height: 2px;
      background: rgba(0, 255, 255, 0.8);
      box-shadow: 0 0 10px cyan;
      animation: scan 2s infinite linear;
    }
    @keyframes scan {
      0% { top: 0%; opacity: 0; }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { top: 100%; opacity: 0; }
    }
    
    #snapBtn {
      pointer-events: auto;
      background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
      border: 1px solid rgba(255, 255, 255, 0.3);
      color: #fff; padding: 16px 40px; border-radius: 50px;
      font-size: 16px; backdrop-filter: blur(10px);
      transition: all 0.2s ease; cursor: pointer; text-transform: uppercase; letter-spacing: 2px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    }
    #snapBtn:hover { background: rgba(255, 255, 255, 0.2); transform: scale(1.05); color: cyan; border-color: cyan; }
    #snapBtn:active { transform: scale(0.95); }
    #snapBtn:disabled { opacity: 0.5; transform: scale(1); cursor: wait; border-color: #555; color: #aaa; }

    /* ìº¡ì³ìš© ìº”ë²„ìŠ¤ (ìˆ¨ê¹€) */
    #snap { display: none; } 
  </style>
</head>
<body>

<div id="container"></div>

<div id="ui-layer">
  <div id="info">ë‚˜ì˜ í˜•ìƒì´ ë°ì´í„° ì…ìë¡œ ì¬êµ¬ì„±ë©ë‹ˆë‹¤.</div>
  
  <div id="camera-frame">
    <video id="cam" autoplay playsinline muted></video>
    <div id="scan-line"></div>
  </div>

  <button id="snapBtn">ğŸ“¸ CAPTURE</button>
</div>

<canvas id="snap" width="640" height="480"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
// [ì„œë²„ ì£¼ì†Œ]
const SERVER_URL = "https://emotion-server-backend-907115489834.asia-northeast3.run.app/analyze";


/* ================= 1. ì¹´ë©”ë¼ ë¡œì§ ================= */
let stream = null;
const snapBtn = document.getElementById("snapBtn");
const info = document.getElementById("info");

async function startCamera() {
  const video = document.getElementById("cam");
  try {
    stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "user" } });
    video.srcObject = stream;
  } catch (e) { info.textContent = "ì¹´ë©”ë¼ ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤."; }
}
window.addEventListener("load", startCamera);

snapBtn.addEventListener("click", async () => {
  const video = document.getElementById("cam");
  const canvas = document.getElementById("snap");
  const ctx = canvas.getContext("2d");

  if (!stream) { startCamera(); return; }
  
  snapBtn.textContent = "ANALYZING...";
  snapBtn.disabled = true;

  // 1. ë²„íŠ¼ ëˆ„ë¥´ëŠ” ìˆœê°„ ì‹œê°ì  í”¼ë“œë°± (ë¨¼ì € í­ë°œì‹œí‚´)
  triggerExplosion(); 

  // ìº¡ì³
  ctx.save();
  ctx.scale(-1, 1);
  ctx.drawImage(video, -canvas.width, 0, canvas.width, canvas.height);
  ctx.restore();

  canvas.toBlob(async blob => {
    if(!blob) { resetBtn(); return; }
    const form = new FormData();
    form.append("frame", blob, "frame.jpg");
    
    try {
      const res = await fetch(SERVER_URL, { method: "POST", body: form });
      if(!res.ok) throw new Error("Server Error");
      
      const data = await res.json();
      
      if (data.status === "ok") {
        info.textContent = "ê°ì • ë°ì´í„°ê°€ í˜•ìƒì„ ì¬êµ¬ì„±í•©ë‹ˆë‹¤.";
        // 2. ë°ì´í„° ë„ì°©í•˜ë©´ ì…ìë“¤ì´ ëª¨ì—¬ë“¤ê¸° ì‹œì‘
        updateParticles(data);
      } else if (data.status === "no_face") {
        info.textContent = "ì–¼êµ´ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.";
        disperseParticles();
      }
    } catch (e) { 
      console.error(e); 
      info.textContent = "ì„œë²„ ì—°ê²° ì‹¤íŒ¨"; 
    } finally { 
      resetBtn(); 
    }
  }, "image/jpeg", 0.9);
});

function resetBtn() {
  snapBtn.disabled = false;
  snapBtn.textContent = "ğŸ“¸ CAPTURE";
}


/* ================= 2. Three.js: Dynamic Mirror ================= */
let scene, camera, renderer, points;
let particlesData = []; 
const PARTICLE_COUNT = 5500; // ì…ì ìˆ˜ ì•½ê°„ ì¦ê°€

let currentEmotions = { joy: 0, sorrow: 0, anger: 0, surprise: 0 };
let hasFace = false;
let flashIntensity = 0.0; // ìº¡ì³ ì‹œ ë²ˆì©ì´ëŠ” íš¨ê³¼ìš©

function initThree() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x050505);

  const aspect = window.innerWidth / window.innerHeight;
  camera = new THREE.PerspectiveCamera(50, aspect, 0.1, 1000);
  camera.position.z = 400; 

  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  document.getElementById("container").appendChild(renderer.domElement);

  const posArray = new Float32Array(PARTICLE_COUNT * 3);
  const colorArray = new Float32Array(PARTICLE_COUNT * 3);

  for(let i=0; i<PARTICLE_COUNT; i++) {
    // ì´ˆê¸°: ëœë¤ í™•ì‚° ìƒíƒœ
    const x = (Math.random() - 0.5) * 900;
    const y = (Math.random() - 0.5) * 900;
    const z = (Math.random() - 0.5) * 500;
    
    posArray[i*3] = x;
    posArray[i*3+1] = y;
    posArray[i*3+2] = z;

    particlesData.push({
      ox: x, oy: y, oz: z, // Reset ìœ„ì¹˜
      tx: x, ty: y, tz: z, // Target ìœ„ì¹˜
      vx: 0, vy: 0, vz: 0, // ë¬¼ë¦¬ ì†ë„ (Velocity) - ë‹¤ì´ë‚˜ë¯¹í•¨ì˜ í•µì‹¬
      speed: 0.05
    });

    colorArray[i*3] = 0.3; colorArray[i*3+1] = 0.3; colorArray[i*3+2] = 0.3;
  }

  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
  geometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));

  const material = new THREE.PointsMaterial({
    size: 2.8,
    vertexColors: true,
    transparent: true,
    opacity: 0.9,
    blending: THREE.AdditiveBlending,
    sizeAttenuation: true
  });

  points = new THREE.Points(geometry, material);
  scene.add(points);

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
}

// [í•µì‹¬ ê¸°ëŠ¥] ë²„íŠ¼ ëˆ„ë¥´ë©´ ì…ì í­ë°œ (Reset & Shock)
function triggerExplosion() {
  const positions = points.geometry.attributes.position.array;
  
  // í™”ë©´ ë²ˆì©
  flashIntensity = 1.0; 

  for(let i=0; i<PARTICLE_COUNT; i++) {
    const p = particlesData[i];
    
    // í˜„ì¬ ìœ„ì¹˜ì—ì„œ ë°–ìœ¼ë¡œ í™• íŠ•ê²¨ë‚˜ê°€ëŠ” í˜ì„ ì¤Œ
    const dirX = (Math.random() - 0.5);
    const dirY = (Math.random() - 0.5);
    const dirZ = (Math.random() - 0.5);
    
    // ê°•í•œ ì¶©ê²©ëŸ‰ (Impulse)
    p.vx = dirX * 150; 
    p.vy = dirY * 150; 
    p.vz = dirZ * 150;
    
    // íƒ€ê²Ÿì„ ì¼ì‹œì ìœ¼ë¡œ ëœë¤ìœ¼ë¡œ ëŒë¦¼ (í˜¼ëˆ)
    p.tx = p.ox; 
    p.ty = p.oy; 
    p.tz = p.oz;
  }
}

function updateParticles(data) {
  if (!data.landmarks || !data.face_rect) return;
  
  hasFace = true;
  currentEmotions = data.emotions;

  const rect = data.face_rect;
  const centerX = (rect.min_x + rect.max_x) / 2;
  const centerY = (rect.min_y + rect.max_y) / 2;
  
  const landmarks3D = data.landmarks.map(lm => {
    return {
      x: (lm.x - centerX) * 1.3,
      y: -(lm.y - centerY) * 1.3,
      z: lm.z || 0
    };
  });

  particlesData.forEach((p, i) => {
    const targetLm = landmarks3D[i % landmarks3D.length];
    
    // ìƒˆë¡œìš´ ëª©í‘œ ì„¤ì • (ì–¼êµ´ í˜•ìƒ)
    p.tx = targetLm.x + (Math.random() - 0.5) * 12;
    p.ty = targetLm.y + (Math.random() - 0.5) * 12;
    p.tz = (targetLm.z * 3) + (Math.random() - 0.5) * 15;
    
    // [ì¤‘ìš”] ëª¨ì¼ ë•Œ ì†ë„ë¥¼ ë‹¤ì‹œ ë¹ ë¥´ê²Œ í•´ì„œ 'ë¹¨ë ¤ ë“¤ì–´ê°€ëŠ”' ëŠë‚Œ ì¤Œ
    p.speed = 0.08 + Math.random() * 0.05; 
  });
}

function disperseParticles() {
  hasFace = false;
  particlesData.forEach(p => {
    p.tx = p.ox; p.ty = p.oy; p.tz = p.oz;
    // í©ì–´ì§ˆ ë•Œë„ ì‚´ì§ íŠ•ê¸°ê²Œ
    p.vx += (Math.random()-0.5) * 10;
    p.vy += (Math.random()-0.5) * 10;
  });
}

function animate() {
  requestAnimationFrame(animate);

  const positions = points.geometry.attributes.position.array;
  const colors = points.geometry.attributes.color.array;
  
  const { joy, sorrow, anger, surprise } = currentEmotions;
  const time = Date.now() * 0.001;

  // ë²ˆì©ì´ëŠ” íš¨ê³¼ ì„œì„œíˆ ê°ì†Œ
  if(flashIntensity > 0) flashIntensity *= 0.9;

  let tr = 0.5, tg = 0.6, tb = 0.7; 
  if (hasFace) {
    if (joy > 0.1) { tr=1.0; tg=0.8; tb=0.2; }
    if (anger > 0.1) { tr=1.0; tg=0.1; tb=0.1; }
    if (sorrow > 0.1) { tr=0.1; tg=0.3; tb=1.0; }
    if (surprise > 0.1) { tr=1.0; tg=1.0; tb=1.0; }
  }

  for (let i = 0; i < PARTICLE_COUNT; i++) {
    const p = particlesData[i];
    const idx = i * 3;

    let cx = positions[idx];
    let cy = positions[idx+1];
    let cz = positions[idx+2];

    // 1. ë¬¼ë¦¬ ì†ë„ (Velocity) ì ìš©
    // í­ë°œí•  ë•Œ ìƒê¸´ vx, vy, vzê°€ ìœ„ì¹˜ë¥¼ ë°€ì–´ëƒ„
    cx += p.vx;
    cy += p.vy;
    cz += p.vz;
    
    // ì†ë„ëŠ” ë§ˆì°°ë ¥ì— ì˜í•´ ì ì  ì¤„ì–´ë“¦ (Damping)
    p.vx *= 0.9;
    p.vy *= 0.9;
    p.vz *= 0.9;

    // 2. ëª©í‘œ ìœ„ì¹˜ë¡œ ì´ë™ (Lerp)
    // ê°ì •ì— ë”°ë¥¸ ì¶”ê°€ ë³€í˜•
    let tx = p.tx; let ty = p.ty; let tz = p.tz;

    if (hasFace) {
      if (sorrow > 0.1) {
        ty -= Math.abs(Math.sin(time * 2 + cx * 0.05)) * sorrow * 40;
      }
      if (joy > 0.1) {
        ty += Math.sin(time * 3 + cx * 0.1) * joy * 10;
        tx += Math.cos(time * 2 + cy * 0.1) * joy * 5;
      }
      if (anger > 0.1) {
        tx += (Math.random() - 0.5) * anger * 20;
        ty += (Math.random() - 0.5) * anger * 20;
      }
    }

    // ëª©í‘œ ìœ„ì¹˜ë¡œ ë¶€ë“œëŸ½ê²Œ ëŒë ¤ê°
    cx += (tx - cx) * p.speed;
    cy += (ty - cy) * p.speed;
    cz += (tz - cz) * p.speed;

    positions[idx] = cx;
    positions[idx+1] = cy;
    positions[idx+2] = cz;

    // ìƒ‰ìƒ ì—…ë°ì´íŠ¸ (ë²ˆì©ì´ëŠ” íš¨ê³¼ flashIntensity ì¶”ê°€)
    colors[idx] += (tr - colors[idx]) * 0.05 + flashIntensity;
    colors[idx+1] += (tg - colors[idx+1]) * 0.05 + flashIntensity;
    colors[idx+2] += (tb - colors[idx+2]) * 0.05 + flashIntensity;
  }

  if (hasFace) points.rotation.y = Math.sin(time * 0.5) * 0.05;
  else points.rotation.y += 0.001;

  points.geometry.attributes.position.needsUpdate = true;
  points.geometry.attributes.color.needsUpdate = true;

  renderer.render(scene, camera);
}

initThree();
animate();

</script>
</body>
</html>
