<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>AI Emotion Sphere</title>
  <style>
    /* ================= ë ˆì´ì•„ì›ƒ & ìŠ¤íƒ€ì¼ ================= */
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background: #000;
      font-family: sans-serif;
      overflow: hidden; /* ìŠ¤í¬ë¡¤ ë°©ì§€ */
      user-select: none; /* í…ìŠ¤íŠ¸ ì„ íƒ ë°©ì§€ */
    }

    /* 1. Three.js ë°°ê²½ (ê°€ì¥ ë’¤) */
    #container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
    }

    /* 2. UI ë ˆì´ì–´ (í™”ë©´ ì „ì²´ë¥¼ ë®ëŠ” íˆ¬ëª…í•œ ë°•ìŠ¤) */
    #ui-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 10;
      pointer-events: none; /* ë°°ê²½ì˜ êµ¬ë¥¼ ê°€ë¦¬ì§€ ì•Šê²Œ í„°ì¹˜ í†µê³¼ */
      
      display: flex;
      flex-direction: column;
      justify-content: flex-end; /* ë‚´ìš©ë¬¼ì„ ë§¨ ì•„ë˜ë¡œ */
      align-items: center;       /* ì¢Œìš° ì¤‘ì•™ ì •ë ¬ */
      padding-bottom: 30px;      /* ë°”ë‹¥ì—ì„œ ì¡°ê¸ˆ ë„ì›€ */
      box-sizing: border-box;
    }

    /* ì •ë³´ í…ìŠ¤íŠ¸ (ìƒë‹¨ ì¤‘ì•™) */
    #info {
      position: absolute;
      top: 20px;
      width: 100%;
      text-align: center;
      color: rgba(255, 255, 255, 0.5);
      font-size: 14px;
      text-shadow: 0 1px 3px rgba(0,0,0,0.8);
      pointer-events: auto;
    }

    /* ì¹´ë©”ë¼ ë˜í¼ (ë¹„ë””ì˜¤ + ê°€ì´ë“œë¼ì¸) */
    #camera-wrapper {
      position: relative;
      background: #000;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 16px;
      overflow: hidden;
      margin-bottom: 20px; /* ë²„íŠ¼ê³¼ì˜ ê°„ê²© */
      pointer-events: auto; /* í„°ì¹˜ ê°€ëŠ¥ */
      box-shadow: 0 4px 20px rgba(0,0,0,0.5);
      
      /* ê¸°ë³¸ í¬ê¸° (í•¸ë“œí° ê¸°ì¤€) */
      width: 60vw;  
      height: 60vw; 
      max-width: 300px;
      max-height: 300px;
      /* ì›í˜•ì— ê°€ê¹ê²Œ? ì•„ë‹ˆë©´ ì‚¬ê°í˜•? -> ì•½ê°„ ë‘¥ê·¼ ì‚¬ê°í˜• ìœ ì§€ */
    }

    /* íƒœë¸”ë¦¿/PCì¼ ë•Œ ì¹´ë©”ë¼ í¬ê¸° í‚¤ì›€ (ë¯¸ë””ì–´ ì¿¼ë¦¬) */
    @media (min-width: 768px) {
      #camera-wrapper {
        width: 320px;
        height: 240px;
        margin-bottom: 30px;
      }
    }

    #cam {
      width: 100%;
      height: 100%;
      object-fit: cover;
      transform: scaleX(-1); /* ê±°ìš¸ ëª¨ë“œ */
    }

    /* ì–¼êµ´ ê°€ì´ë“œë¼ì¸ */
    #face-guide {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 50%;
      height: 70%;
      border: 2px dashed rgba(255, 255, 255, 0.6);
      border-radius: 50%;
      box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.2); /* ì£¼ë³€ì„ ì•½ê°„ ì–´ë‘¡ê²Œ */
    }

    /* ìº¡ì³ ë²„íŠ¼ (ë§¨ ì•„ë˜) */
    #snapBtn {
      pointer-events: auto;
      width: 80%;
      max-width: 400px;
      padding: 18px 0;
      font-size: 18px;
      font-weight: bold;
      color: #fff;
      background: linear-gradient(135deg, #00d2ff, #3a7bd5); /* Cyan Blue ê³„ì—´ */
      border: none;
      border-radius: 50px;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(0, 210, 255, 0.4);
      transition: transform 0.2s, background 0.3s;
    }
    #snapBtn:active {
      transform: scale(0.96);
      background: linear-gradient(135deg, #00a8cc, #285a9e);
    }
    #snapBtn:disabled {
      background: #555;
      color: #aaa;
      cursor: not-allowed;
    }

    /* ìº¡ì³ìš© ìº”ë²„ìŠ¤ (ìˆ¨ê¹€) */
    #snap { display: none; }
  </style>
</head>
<body>

  <div id="container"></div>

  <div id="ui-layer">
    <div id="info">ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì¤‘...</div>

    <div id="camera-wrapper">
      <video id="cam" autoplay playsinline muted></video>
      <div id="face-guide"></div>
    </div>

    <button id="snapBtn">ğŸ“¸ ê°ì • ë¶„ì„ ì‹œì‘</button>
  </div>

  <canvas id="snap" width="640" height="480"></canvas>


<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
/* [ì„œë²„ ì£¼ì†Œ ì„¤ì •] 
   Cloud Run ì£¼ì†Œë¡œ ê¼­ ë°”ê¿”ì£¼ì„¸ìš”! (ë’¤ì— /analyze í¬í•¨)
*/
const SERVER_URL = "https://emotion-server-backend-907115489834.asia-northeast3.run.app/analyze";


/* ================= 1. ì¹´ë©”ë¼ ìë™ ì‹¤í–‰ ================= */
let stream = null;

async function startCamera() {
  const info = document.getElementById("info");
  const video = document.getElementById("cam");

  try {
    // ëª¨ë°”ì¼ ì „ë©´ ì¹´ë©”ë¼ ìš°ì„ 
    stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: "user", width: 640, height: 480 }
    });
    video.srcObject = stream;
    info.innerHTML = "ì–¼êµ´ì„ ê°€ì´ë“œì— ë§ì¶”ê³  ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.";
  } catch (e) {
    console.error(e);
    info.innerHTML = "ì¹´ë©”ë¼ ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤.<br>ìƒˆë¡œê³ ì¹¨ í•˜ê±°ë‚˜ ì„¤ì •ì—ì„œ í—ˆìš©í•´ì£¼ì„¸ìš”.";
  }
}

// í˜ì´ì§€ ë¡œë“œ ë˜ìë§ˆì ì¹´ë©”ë¼ ì¼œê¸°
window.addEventListener("load", startCamera);


/* ================= 2. ì‚¬ì§„ ìº¡ì³ ë° ë¶„ì„ ================= */
const snapBtn = document.getElementById("snapBtn");
const info = document.getElementById("info");

snapBtn.addEventListener("click", async () => {
  const video = document.getElementById("cam");
  const canvas = document.getElementById("snap");
  const ctx = canvas.getContext("2d");

  if (!stream) {
    startCamera(); // í˜¹ì‹œ ì•ˆ ì¼œì ¸ìˆìœ¼ë©´ ì¬ì‹œë„
    return;
  }

  // ë²„íŠ¼ ë¹„í™œì„±í™”
  snapBtn.disabled = true;
  snapBtn.textContent = "âŒ› ë¶„ì„ ì¤‘...";

  // í™”ë©´ ìº¡ì³ (ì¢Œìš° ë°˜ì „ ë³´ì •)
  ctx.save();
  ctx.scale(-1, 1);
  ctx.drawImage(video, -canvas.width, 0, canvas.width, canvas.height);
  ctx.restore();

  // Blob ë³€í™˜ ë° ì „ì†¡
  canvas.toBlob(async blob => {
    if(!blob) {
      info.textContent = "ì´ë¯¸ì§€ ì²˜ë¦¬ ì˜¤ë¥˜";
      resetBtn(); 
      return;
    }

    const form = new FormData();
    form.append("frame", blob, "frame.jpg");

    try {
      info.textContent = "ì„œë²„ì™€ í†µì‹  ì¤‘...";
      const res = await fetch(SERVER_URL, { method: "POST", body: form });
      
      if (!res.ok) throw new Error("ì„œë²„ ì‘ë‹µ ì˜¤ë¥˜");
      const data = await res.json();

      if (data.status === "ok") {
        info.textContent = "ë¶„ì„ ì™„ë£Œ. ê°ì •ì´ í˜•ìƒí™”ë©ë‹ˆë‹¤.";
        updateSphereFromEmotion(data);
      } else {
        throw new Error(data.error || "ë¶„ì„ ì‹¤íŒ¨");
      }
    } catch (err) {
      console.error(err);
      info.textContent = "ì˜¤ë¥˜: " + err.message;
      alert("ì„œë²„ ì—°ê²° ì‹¤íŒ¨. ì£¼ì†Œë¥¼ í™•ì¸í•˜ì„¸ìš”.");
    } finally {
      resetBtn();
    }
  }, "image/jpeg", 0.9);
});

function resetBtn() {
  snapBtn.disabled = false;
  snapBtn.textContent = "ğŸ“¸ ë‹¤ì‹œ ì°ê¸°";
}


/* ================= 3. Three.js: Digital Entropy (AI Logic) ================= */
// [ìˆ˜ì •ë¨] êµ¬ì˜ ìœ„ì¹˜ë¥¼ í™”ë©´ ìƒë‹¨ìœ¼ë¡œ ì˜¬ë¦¼
let scene, camera, renderer, geometry, points;
let basePositions = []; 

// ëª©í‘œ ê°ì • ìƒíƒœ
let targetEmotions = { joy: 0, sorrow: 0, anger: 0, surprise: 0, arousal: 0 };
let currentEmotions = { joy: 0, sorrow: 0, anger: 0, surprise: 0, arousal: 0 };

function initThree() {
  const container = document.getElementById("container");
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000); 

  const W = window.innerWidth;
  const H = window.innerHeight;

  camera = new THREE.PerspectiveCamera(45, W / H, 0.1, 100);
  camera.position.set(0, 0, 9); 

  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(W, H);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  container.appendChild(renderer.domElement);

  // ì…ì ìƒì„±
  const count = 4500;
  const positions = new Float32Array(count * 3);
  const colors = new Float32Array(count * 3);
  const R = 2.0; 

  basePositions = [];

  for (let i = 0; i < count; i++) {
    const goldenRatio = (1 + Math.sqrt(5)) / 2;
    const theta = 2 * Math.PI * i / goldenRatio;
    const phi = Math.acos(1 - 2 * (i + 0.5) / count);

    const x = R * Math.sin(phi) * Math.cos(theta);
    const y = R * Math.sin(phi) * Math.sin(theta);
    const z = R * Math.cos(phi);

    positions[i * 3] = x;
    positions[i * 3 + 1] = y;
    positions[i * 3 + 2] = z;

    basePositions.push({x, y, z});

    colors[i * 3] = 0.0;
    colors[i * 3 + 1] = 1.0;
    colors[i * 3 + 2] = 1.0;
  }

  geometry = new THREE.BufferGeometry();
  geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
  geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

  const material = new THREE.PointsMaterial({
    size: 0.04,
    vertexColors: true,
    transparent: true,
    opacity: 0.8,
    blending: THREE.AdditiveBlending
  });

  points = new THREE.Points(geometry, material);
  
  // [ì¤‘ìš”] êµ¬ì˜ ìœ„ì¹˜ë¥¼ ìœ„ë¡œ ì˜¬ë¦¼ (Yì¶• +1.2)
  // í•˜ë‹¨ UI(ì¹´ë©”ë¼, ë²„íŠ¼)ì— ê°€ë ¤ì§€ì§€ ì•Šê²Œ í•˜ê¸° ìœ„í•¨
  points.position.y = 1.2; 
  
  scene.add(points);

  window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
}

function lerp(start, end, t) {
  return start * (1 - t) + end * t;
}

function animate() {
  requestAnimationFrame(animate);

  if (!points) return;

  const speed = 0.08;
  currentEmotions.joy = lerp(currentEmotions.joy, targetEmotions.joy, speed);
  currentEmotions.sorrow = lerp(currentEmotions.sorrow, targetEmotions.sorrow, speed);
  currentEmotions.anger = lerp(currentEmotions.anger, targetEmotions.anger, speed);
  currentEmotions.surprise = lerp(currentEmotions.surprise, targetEmotions.surprise, speed);
  currentEmotions.arousal = lerp(currentEmotions.arousal, targetEmotions.arousal, speed);

  const positions = geometry.attributes.position.array;
  const colors = geometry.attributes.color.array;
  const time = performance.now() * 0.001;
  
  const { joy, sorrow, anger, surprise, arousal } = currentEmotions;

  points.rotation.y = time * 0.2;
  if (Math.random() < anger * 0.3) {
      points.rotation.y += (Math.random() - 0.5) * 0.5;
  }

  for (let i = 0; i < basePositions.length; i++) {
    const base = basePositions[i];
    const idx = i * 3;

    let nx = base.x;
    let ny = base.y;
    let nz = base.z;

    const joyWave = Math.sin(time * 3 + base.y * 2) * joy * 0.5;
    const joyExpand = 1.0 + (joy * 0.5);
    const glitchX = (Math.random() - 0.5) * anger * 0.6;
    const glitchY = (Math.random() - 0.5) * anger * 0.6;
    const glitchZ = (Math.random() - 0.5) * anger * 0.6;
    const collapse = 1.0 - (sorrow * 0.6);
    const scatter = surprise * Math.sin(time * 10 + i) * 0.3;

    nx *= joyExpand * collapse;
    ny *= joyExpand * collapse;
    nz *= joyExpand * collapse;
    nx += base.x * joyWave + glitchX + scatter;
    ny += base.y * joyWave + glitchY + scatter;
    nz += base.z * joyWave + glitchZ + scatter;

    if (sorrow > 0.1) {
        ny -= Math.abs(Math.sin(time * 0.5 + base.x)) * sorrow * 1.5;
    }

    positions[idx] = nx;
    positions[idx + 1] = ny;
    positions[idx + 2] = nz;

    // Color Logic
    let r = 0.0, g = 1.0, b = 1.0; // Cyan Base

    if (joy > 0.1) { r += joy; g -= joy * 0.5; }
    if (anger > 0.1) { 
        const flash = Math.sin(time * 30) > 0 ? 1 : 0.5;
        r += anger * flash; g -= anger; b -= anger; 
    }
    if (sorrow > 0.1) { r = 0.1; g = 0.1 + (1-sorrow)*0.5; b = 0.3 + (1-sorrow)*0.7; }
    if (surprise > 0.1) { r += surprise; g += surprise; b += surprise; }
    
    r += arousal * 0.2; g += arousal * 0.2; b += arousal * 0.2;

    colors[idx] = Math.min(1, Math.max(0, r));
    colors[idx + 1] = Math.min(1, Math.max(0, g));
    colors[idx + 2] = Math.min(1, Math.max(0, b));
  }

  geometry.attributes.position.needsUpdate = true;
  geometry.attributes.color.needsUpdate = true;
  
  renderer.render(scene, camera);
}

function updateSphereFromEmotion(data) {
  if (!data.emotions) return;
  const e = data.emotions;
  targetEmotions.joy = e.joy || 0;
  targetEmotions.sorrow = e.sorrow || 0;
  targetEmotions.anger = e.anger || 0;
  targetEmotions.surprise = e.surprise || 0;
  targetEmotions.arousal = (data.arousal || 0) * 0.5; 
}

initThree();
animate();
</script>
</body>
</html>
