<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Digital Aura Exhibition</title>
  <style>
    /* 기본 설정 */
    body { margin: 0; overflow: hidden; background: #000; font-family: 'Pretendard', sans-serif; user-select: none; }
    
    /* Three.js 배경 (가장 뒤) */
    #container { position: absolute; width: 100%; height: 100%; top: 0; left: 0; z-index: 0; }
    
    /* 공통 UI 스타일 */
    .screen {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      transition: opacity 0.5s ease;
      z-index: 10;
      pointer-events: none; /* 배경 터치 통과 */
    }
    .screen.hidden { opacity: 0; pointer-events: none; display: none; } /* display: none 추가 */
    .screen.active { opacity: 1; pointer-events: auto; display: flex; }

    /* 버튼 스타일 */
    button {
      padding: 15px 40px;
      border: 1px solid rgba(255, 255, 255, 0.4);
      background: rgba(0, 0, 0, 0.5);
      color: #fff; font-size: 16px; letter-spacing: 2px;
      cursor: pointer; border-radius: 4px;
      backdrop-filter: blur(5px);
      transition: all 0.3s;
      pointer-events: auto;
      text-transform: uppercase;
    }
    button:hover { background: rgba(255, 255, 255, 0.2); border-color: #fff; }
    button:active { transform: scale(0.95); }


    /* 1. 대기 화면 (Start Screen) */
    #start-screen { z-index: 30; background: #000; } 
    #startBtn {
      border: none; background: transparent;
      font-size: 24px; letter-spacing: 5px;
      animation: pulse 2s infinite;
    }
    @keyframes pulse { 0% { opacity: 0.4; } 50% { opacity: 1; } 100% { opacity: 0.4; } }


    /* 2. 카메라 화면 (Camera Screen) */
    #camera-screen {
      justify-content: flex-end; padding-bottom: 60px;
      background: rgba(0,0,0,0.3); /* 배경 살짝 어둡게 */
    }

    #camera-frame {
      position: absolute; top: 50%; left: 50%;
      transform: translate(-50%, -60%);
      width: 300px; height: 300px; /* 네모난 모양 */
      border: 1px solid rgba(255, 255, 255, 0.3);
      background: #000;
      overflow: hidden;
      box-shadow: 0 0 50px rgba(0,0,0,0.5);
    }

    #cam {
      width: 100%; height: 100%;
      object-fit: cover;
      transform: scaleX(-1); /* 거울모드 */
      opacity: 0.9;
    }

    /* 얼굴 가이드 (네모 안의 타원) */
    #face-guide {
      position: absolute; top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      width: 60%; height: 70%;
      border: 2px dashed rgba(255, 255, 255, 0.5);
      border-radius: 50%;
      box-shadow: 0 0 0 100vmax rgba(0,0,0,0.5); 
    }

    #scanBtn {
      margin-top: 20px; font-weight: bold; background: #fff; color: #000; border: none;
      z-index: 50; /* 버튼이 확실히 위에 오도록 */
    }


    /* 3. 결과/다시하기 화면 (Retry Screen) */
    #retry-screen {
      justify-content: flex-end; padding-bottom: 60px;
    }
    #info-text {
      position: absolute; top: 15%; width: 100%;
      text-align: center; color: rgba(255,255,255,0.7);
      font-size: 16px; letter-spacing: 1px;
    }

    #snap { display: none; }
  </style>
</head>
<body>

<div id="container"></div>

<div id="start-screen" class="screen active">
  <button id="startBtn">TOUCH TO START</button>
</div>

<div id="camera-screen" class="screen hidden">
  <div id="camera-frame">
    <video id="cam" autoplay playsinline muted></video>
    <div id="face-guide"></div>
  </div>
  <button id="scanBtn">SCAN</button>
</div>

<div id="retry-screen" class="screen hidden">
  <div id="info-text">데이터를 해석하고 있습니다...</div>
  <button id="retryBtn">↺ RE-SCAN</button>
</div>

<canvas id="snap" width="640" height="480"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/josephg/noisejs/perlin.js"></script>

<script>
// [서버 주소]
const SERVER_URL = "https://emotion-server-backend-907115489834.asia-northeast3.run.app/analyze";

/* ================= [1] 상태 관리 및 시퀀스 로직 ================= */
const startScreen = document.getElementById("start-screen");
const cameraScreen = document.getElementById("camera-screen");
const retryScreen = document.getElementById("retry-screen");

const startBtn = document.getElementById("startBtn");
const scanBtn = document.getElementById("scanBtn");
const retryBtn = document.getElementById("retryBtn");
const infoText = document.getElementById("info-text");

const videoElement = document.getElementById("cam");
let stream = null;
let idleTimer = null;
const IDLE_LIMIT = 60000; // 1분

// 1. 접속하자마자 카메라 권한 요청
async function initCamera() {
  try {
    console.log("Requesting Camera...");
    stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: "user", width: 640, height: 480 }
    });
    videoElement.srcObject = stream;
    await videoElement.play();
    console.log("Camera started in background.");
  } catch (e) {
    console.warn("Autoplay blocked or permission denied. Waiting for user gesture.", e);
  }
}

window.addEventListener("load", initCamera);

// 2. [TOUCH TO START]
startBtn.addEventListener("click", async () => {
  if (!stream) {
    await initCamera();
  }
  showScreen(cameraScreen);
  resetIdleTimer();
});

// 3. [SCAN]
scanBtn.addEventListener("click", async () => {
  console.log("Scan button clicked");

  if (!stream) {
    await initCamera();
    if (!stream) {
      alert("카메라 오류. 새로고침 해주세요.");
      return;
    }
  }

  resetIdleTimer();

  // UI 전환
  showScreen(null);
  retryScreen.classList.remove("hidden");
  retryScreen.classList.add("active");
  retryBtn.style.display = "none";
  infoText.textContent = "데이터를 해석하고 있습니다...";

  setAnalyzingState(true);

  const canvas = document.getElementById("snap");
  const ctx = canvas.getContext("2d");

  if (videoElement.videoWidth > 0) {
    canvas.width = videoElement.videoWidth;
    canvas.height = videoElement.videoHeight;
  }

  // 좌우반전 캡처
  ctx.save();
  ctx.scale(-1, 1);
  ctx.drawImage(videoElement, -canvas.width, 0, canvas.width, canvas.height);
  ctx.restore();

  canvas.toBlob(async blob => {
    const form = new FormData();
    form.append("frame", blob, "frame.jpg");

    try {
      console.log("Sending to server...");
      const res = await fetch(SERVER_URL, { method: "POST", body: form });
      if (!res.ok) throw new Error("Server Error");
      const data = await res.json();
      console.log("Data received:", data);

      if (data.status === "ok") {
        infoText.textContent = "";
        updateAbstractShape(data); // ← 추상 형상 업데이트
      } else {
        infoText.textContent = "인식된 얼굴이 없습니다.";
        resetEmotion(false);
      }
    } catch (e) {
      console.error(e);
      infoText.textContent = "서버 연결 실패";
      resetEmotion(false);
    } finally {
      setAnalyzingState(false);
      setTimeout(() => {
        retryBtn.style.display = "block";
      }, 2000);
    }
  }, "image/jpeg", 0.9);
});

// 4. [RE-SCAN]
retryBtn.addEventListener("click", () => {
  resetIdleTimer();
  showScreen(cameraScreen);
  setBackgroundState();
  if (videoElement.paused) videoElement.play();
});

// 5. 자동 초기화
function resetIdleTimer() {
  if (idleTimer) clearTimeout(idleTimer);
  idleTimer = setTimeout(() => {
    console.log("Timeout -> Reset to Start Screen");
    showScreen(startScreen);
    resetEmotion(true);
    stopIdleTimer();
  }, IDLE_LIMIT);
}
function stopIdleTimer() {
  if (idleTimer) clearTimeout(idleTimer);
  idleTimer = null;
}

function showScreen(target) {
  [startScreen, cameraScreen, retryScreen].forEach(s => {
    s.classList.remove("active");
    s.classList.add("hidden");
  });
  if (target) {
    target.classList.remove("hidden");
    target.classList.add("active");
  }
}

// 인터랙션 감지
window.addEventListener("touchstart", () => {
  if (!startScreen.classList.contains("active")) resetIdleTimer();
});
window.addEventListener("click", () => {
  if (!startScreen.classList.contains("active")) resetIdleTimer();
});


/* ================= [2] 감정 → 완전 추상 형상 (Inkblot) ================= */

// #container 안에 풀스크린 캔버스 하나 추가
const container = document.getElementById("container");
const emotionCanvas = document.createElement("canvas");
emotionCanvas.id = "emotionCanvas";
emotionCanvas.style.position = "absolute";
emotionCanvas.style.top = "0";
emotionCanvas.style.left = "0";
emotionCanvas.style.width = "100%";
emotionCanvas.style.height = "100%";
emotionCanvas.style.pointerEvents = "none";
container.appendChild(emotionCanvas);

const ectx = emotionCanvas.getContext("2d");
let cw = 0;
let ch = 0;

// hiDPI 대응
function resizeEmotionCanvas() {
  const dpr = window.devicePixelRatio || 1;
  const rect = container.getBoundingClientRect();
  cw = rect.width;
  ch = rect.height;
  emotionCanvas.width = rect.width * dpr;
  emotionCanvas.height = rect.height * dpr;
  ectx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
window.addEventListener("resize", resizeEmotionCanvas);
resizeEmotionCanvas();

// 감정 상태 (내부에서만 사용, 화면에 직접 노출 X)
let currentEmotion = {
  joy: 0,
  sorrow: 0,
  anger: 0,
  surprise: 0,
  valence: 0,      // joy - sorrow
  energy: 0,       // max intensity
  tension: 0,      // anger
  instability: 0   // surprise
};

let targetEmotion = { ...currentEmotion };
let analyzing = false;
let lastTime = 0;

// 랜덤 시드 (각 사람마다 다르게 약간 변형되도록)
let baseSeed = Math.random() * 1000;

function lerp(a, b, t) { return a + (b - a) * t; }

// 원시 감정값 → 조합된 지표
function processEmotions(raw) {
  let joy = raw.joy ?? 0;
  let sorrow = raw.sorrow ?? 0;
  let anger = raw.anger ?? 0;
  let surprise = raw.surprise ?? 0;

  // 혹시 0~3 같은 값이면 0~1로 스케일링
  const maxRaw = Math.max(joy, sorrow, anger, surprise, 1);
  if (maxRaw > 1.0) {
    joy /= maxRaw;
    sorrow /= maxRaw;
    anger /= maxRaw;
    surprise /= maxRaw;
  }

  // 아주 작은 값은 노이즈로 보고 컷
  const noiseCut = 0.1;
  if (joy < noiseCut) joy = 0;
  if (sorrow < noiseCut) sorrow = 0;
  if (anger < noiseCut) anger = 0;
  if (surprise < noiseCut) surprise = 0;

  // 다시 normalize
  const sum = joy + sorrow + anger + surprise;
  if (sum > 0) {
    joy /= sum;
    sorrow /= sum;
    anger /= sum;
    surprise /= sum;
  }

  const energy     = sum > 0 ? Math.max(joy, sorrow, anger, surprise) : 0;  // 전체 세기
  const valence    = joy - sorrow;    // +면 '가벼운 쪽', -면 '무거운 쪽'
  const tension    = anger;           // 날카로움
  const instability= surprise;        // 요동

  return { joy, sorrow, anger, surprise, valence, energy, tension, instability };
}

// 서버에서 온 감정 → 추상 형상 파라미터 업데이트
function updateAbstractShape(data) {
  if (!data.emotions) return;
  targetEmotion = processEmotions(data.emotions);

  // 감정이 너무 약하면 거의 정적에 가깝게
  if (targetEmotion.energy < 0.15) {
    targetEmotion.energy = 0.0;
  }

  // 사람마다 살짝 다른 seed 되도록 한 번 섞어줌
  baseSeed = Math.random() * 1000;
}

// 분석 중
function setAnalyzingState(isAnalyzing) {
  analyzing = isAnalyzing;
}

// 카메라 화면으로 돌아갈 때 잔상만 남기기
function setBackgroundState() {
  targetEmotion.energy *= 0.4;
}

// 리셋
function resetEmotion(fully) {
  if (fully) {
    targetEmotion = {
      joy: 0,
      sorrow: 0,
      anger: 0,
      surprise: 0,
      valence: 0,
      energy: 0,
      tension: 0,
      instability: 0
    };
  } else {
    targetEmotion.energy *= 0.2;
  }
}

// 노이즈 함수 (perlin.js 사용)
function n2(x, y, t) {
  return noise.simplex3(x, y, t);
}

// 메인 그리기
function drawAbstractInk(dt) {
  const tLerp = Math.min(dt * 0.004, 0.25);

  // 감정 상태 보간 (부드럽게 변화)
  currentEmotion.joy        = lerp(currentEmotion.joy,        targetEmotion.joy,        tLerp);
  currentEmotion.sorrow     = lerp(currentEmotion.sorrow,     targetEmotion.sorrow,     tLerp);
  currentEmotion.anger      = lerp(currentEmotion.anger,      targetEmotion.anger,      tLerp);
  currentEmotion.surprise   = lerp(currentEmotion.surprise,   targetEmotion.surprise,   tLerp);
  currentEmotion.valence    = lerp(currentEmotion.valence,    targetEmotion.valence,    tLerp);
  currentEmotion.energy     = lerp(currentEmotion.energy,     targetEmotion.energy,     tLerp);
  currentEmotion.tension    = lerp(currentEmotion.tension,    targetEmotion.tension,    tLerp);
  currentEmotion.instability= lerp(currentEmotion.instability,targetEmotion.instability,tLerp);

  const w = cw;
  const h = ch;
  if (!w || !h) return;

  const time = performance.now() * 0.001;

  // 배경: 거의 검정, 약간의 그라데이션
  ectx.clearRect(0, 0, w, h);
  const bgGrad = ectx.createRadialGradient(
    w/2, h*0.4, 0,
    w/2, h*0.4, Math.max(w,h)*0.9
  );
  bgGrad.addColorStop(0, "rgba(0,0,0,0.5)");
  bgGrad.addColorStop(1, "rgba(0,0,0,1)");
  ectx.fillStyle = bgGrad;
  ectx.fillRect(0,0,w,h);

  const cx = w / 2;
  const cy = h * 0.4;

  // 감정 기반 파라미터
  const E  = currentEmotion.energy;      // 전체 강도
  const V  = currentEmotion.valence;     // -1~1 비대칭
  const Tn = currentEmotion.tension;     // 뾰족
  const In = currentEmotion.instability; // 요동

  const baseR = Math.min(w,h) * (0.12 + 0.18*E); // 형상 기본 크기
  const lobesBase = 4;                            // 기본 lobes
  const lobes = lobesBase + Math.round(In * 6 + Tn * 3); // 놀람/분노 많을수록 lobes 증가
  const spikiness = 0.15 + Tn*0.9;                // 분노 → spiky
  const wobbleAmp = 0.05 + In*0.25;               // 놀람 → 요동
  const asymX = V * 0.6;                          // valence → 좌우 비대칭
  const asymY = currentEmotion.sorrow * 0.7;      // 슬픔 → 아래쪽 처짐
  const breathing = Math.sin(time*1.1) * (0.04 + E*0.12);

  // 색: 완전 모노톤은 아니고, 아주 미묘한 틴트만 (감정 추측 불가)
  // 기본 톤을 회색~남보라 계열로 고정하고, 감정은 거의 밝기/농도에만 반영
  const baseL = 0.65 - 0.3*E;   // 에너지 높을수록 조금 더 어두운 중심
  const edgeL = 0.15;           // 바깥쪽은 거의 검정
  const coreColor = `rgba(${baseL*255},${baseL*255},${baseL*255},${0.9*Math.max(E,0.25)})`;
  const edgeColor = `rgba(${edgeL*255},${edgeL*255},${edgeL*255},0)`;

  ectx.save();
  ectx.translate(cx, cy);

  // 분석 중에는 약간 더 빠른 회전
  const rot = analyzing ? time*1.8 : time*0.4;
  ectx.rotate(rot);

  // 메인 잉크 형상
  ectx.beginPath();
  const steps = 260;
  for (let i = 0; i <= steps; i++) {
    const ratio = i / steps;
    const theta = ratio * Math.PI*2;

    // 기본 polar curve + 노이즈
    const lobeTerm = Math.cos(lobes*theta + baseSeed*0.3);
    const wobble = Math.sin(theta*2 + time*1.3 + baseSeed) * wobbleAmp;

    // 노이즈(단순한 주기 말고 perlin)
    const nx = Math.cos(theta);
    const ny = Math.sin(theta);
    const n = n2(nx*0.8 + baseSeed, ny*0.8, time*0.4*(1+In));

    let r = baseR * (1 + spikiness*lobeTerm + wobble + breathing + n*0.25);

    // 비대칭 변형
    const ax = 1 + asymX * Math.cos(theta);
    const ay = 1 + asymY * Math.sin(theta - Math.PI/2);

    const x = Math.cos(theta) * r * ax;
    const y = Math.sin(theta) * r * ay + asymY*baseR*0.4;

    if (i === 0) ectx.moveTo(x,y);
    else ectx.lineTo(x,y);
  }
  ectx.closePath();

  // 잉크처럼 안쪽 롤-오프 그라데이션
  const grad = ectx.createRadialGradient(0,0,baseR*0.15, 0,0,baseR*1.5);
  grad.addColorStop(0, coreColor);
  grad.addColorStop(1, edgeColor);

  ectx.fillStyle = grad;
  ectx.fill();

  // 윤곽선: 약간만 강조 (감정색을 직접적으로 쓰지 않음)
  ectx.lineWidth = 0.8 + 2.5*Tn;
  ectx.strokeStyle = `rgba(255,255,255,${0.12 + 0.3*Tn})`;
  ectx.stroke();

  // 내부에 레이어 하나 더 (겹겹이 잉크 번진 느낌)
  ectx.globalAlpha = 0.45 + 0.3*E;
  ectx.beginPath();
  for (let i = 0; i <= steps; i++) {
    const ratio = i / steps;
    const theta = ratio * Math.PI*2;

    const lobeTerm = Math.cos((lobes+1)*theta + baseSeed*0.73);
    const wobble = Math.sin(theta*3 + time*0.9 + baseSeed*1.3) * wobbleAmp*0.6;
    const nx = Math.cos(theta+0.5);
    const ny = Math.sin(theta+0.5);
    const n = n2(nx*1.1 + baseSeed*1.9, ny*1.1, time*0.5*(1+In*0.8));

    let r = baseR*0.7 * (1 + spikiness*0.6*lobeTerm + wobble + n*0.35 + breathing*0.7);

    const ax = 1 + asymX*0.4 * Math.cos(theta+0.7);
    const ay = 1 + asymY*0.5 * Math.sin(theta);

    const x = Math.cos(theta) * r * ax;
    const y = Math.sin(theta) * r * ay + asymY*baseR*0.2;

    if (i === 0) ectx.moveTo(x,y);
    else ectx.lineTo(x,y);
  }
  ectx.closePath();

  const innerGrad = ectx.createRadialGradient(0,0,baseR*0.1, 0,0,baseR*1.0);
  innerGrad.addColorStop(0, `rgba(255,255,255,${0.12 + 0.35*E})`);
  innerGrad.addColorStop(1, "rgba(0,0,0,0)");
  ectx.fillStyle = innerGrad;
  ectx.fill();

  ectx.restore();

  // 하단에는 아무 설명도, 텍스트도, 라벨도 없음.
}

// 루프
function loop(ts) {
  if (!lastTime) lastTime = ts;
  const dt = ts - lastTime;
  lastTime = ts;

  drawAbstractInk(dt);
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

</script>
</body>
</html>



