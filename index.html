<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Digital Soul Mirror</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; user-select: none; }
    
    #container { position: absolute; width: 100%; height: 100%; top: 0; left: 0; z-index: 0; }
    
    /* UI ë ˆì´ì–´ */
    #ui-layer {
      position: absolute; bottom: 30px; left: 0; width: 100%;
      display: flex; flex-direction: column; align-items: center; pointer-events: none;
      z-index: 10;
    }
    
    #info {
      color: rgba(255,255,255,0.7); margin-bottom: 20px; font-size: 14px; text-align: center;
      text-shadow: 0 0 5px rgba(0,0,0,0.8); font-weight: 300; letter-spacing: 1px;
    }
    
    #snapBtn {
      pointer-events: auto;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.4);
      color: #fff; padding: 18px 50px; border-radius: 40px;
      font-size: 16px; backdrop-filter: blur(10px);
      transition: all 0.3s ease; cursor: pointer; text-transform: uppercase; letter-spacing: 2px;
    }
    #snapBtn:hover { background: rgba(255, 255, 255, 0.25); box-shadow: 0 0 20px rgba(255,255,255,0.3); transform: scale(1.05); }
    #snapBtn:active { transform: scale(0.95); }
    #snapBtn:disabled { opacity: 0.5; transform: scale(1); cursor: wait; }

    /* ë¶„ì„ìš© ìš”ì†Œ ìˆ¨ê¹€ */
    #cam, #snap { display: none; } 
  </style>
</head>
<body>

<div id="container"></div>

<div id="ui-layer">
  <div id="info">ë‚˜ì˜ í˜•ìƒì´ ë°ì´í„° ì…ìë¡œ ì¬êµ¬ì„±ë©ë‹ˆë‹¤.</div>
  <button id="snapBtn">ğŸ“¸ í˜•ìƒí™” (Capture)</button>
</div>

<video id="cam" autoplay playsinline muted></video>
<canvas id="snap" width="640" height="480"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
// [ì¤‘ìš”] ì—¬ê¸°ì— Cloud Run ì£¼ì†Œë¥¼ ë„£ìœ¼ì„¸ìš”! (ë’¤ì— /analyze í¬í•¨)
const SERVER_URL = "https://emotion-server-backend-907115489834.asia-northeast3.run.app/analyze";


/* ================= 1. ì¹´ë©”ë¼ ë¡œì§ ================= */
let stream = null;
const snapBtn = document.getElementById("snapBtn");
const info = document.getElementById("info");

async function startCamera() {
  const video = document.getElementById("cam");
  try {
    stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "user" } });
    video.srcObject = stream;
  } catch (e) { info.textContent = "ì¹´ë©”ë¼ ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤."; }
}
window.addEventListener("load", startCamera);

snapBtn.addEventListener("click", async () => {
  const video = document.getElementById("cam");
  const canvas = document.getElementById("snap");
  const ctx = canvas.getContext("2d");

  if (!stream) { startCamera(); return; }
  
  snapBtn.textContent = "Processing...";
  snapBtn.disabled = true;

  // ìº¡ì³ (ì¢Œìš°ë°˜ì „)
  ctx.save();
  ctx.scale(-1, 1);
  ctx.drawImage(video, -canvas.width, 0, canvas.width, canvas.height);
  ctx.restore();

  canvas.toBlob(async blob => {
    if(!blob) { resetBtn(); return; }
    const form = new FormData();
    form.append("frame", blob, "frame.jpg");
    
    try {
      const res = await fetch(SERVER_URL, { method: "POST", body: form });
      if(!res.ok) throw new Error("Server Error");
      
      const data = await res.json();
      
      if (data.status === "ok") {
        info.textContent = "ê°ì •ì´ ë‹¹ì‹ ì˜ í˜•ìƒì„ ë³€í™”ì‹œí‚µë‹ˆë‹¤.";
        updateParticles(data);
      } else if (data.status === "no_face") {
        info.textContent = "ì–¼êµ´ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.";
        disperseParticles();
      }
    } catch (e) { 
      console.error(e); 
      info.textContent = "ì„œë²„ ì—°ê²° ì‹¤íŒ¨"; 
    } finally { 
      resetBtn(); 
    }
  }, "image/jpeg", 0.9);
});

function resetBtn() {
  snapBtn.disabled = false;
  snapBtn.textContent = "ğŸ“¸ í˜•ìƒí™” (Capture)";
}


/* ================= 2. Three.js: Digital Soul Mirror ================= */
let scene, camera, renderer, points;
let particlesData = []; 
const PARTICLE_COUNT = 5000; // ì…ì ìˆ˜ (ë§ì„ìˆ˜ë¡ ì •ë°€í•˜ì§€ë§Œ ëŠë ¤ì§)

// ìƒíƒœ ë³€ìˆ˜
let currentEmotions = { joy: 0, sorrow: 0, anger: 0, surprise: 0 };
let hasFace = false;

function initThree() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x050505); // ë”¥ ë‹¤í¬ ë°°ê²½

  // ì¹´ë©”ë¼ ì„¤ì •
  const aspect = window.innerWidth / window.innerHeight;
  camera = new THREE.PerspectiveCamera(50, aspect, 0.1, 1000);
  camera.position.z = 400; 

  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  document.getElementById("container").appendChild(renderer.domElement);

  // ì…ì ì´ˆê¸°í™” (ëœë¤í•œ ìœ„ì¹˜ì— ë¨¼ì§€ì²˜ëŸ¼ ë°°ì¹˜)
  const posArray = new Float32Array(PARTICLE_COUNT * 3);
  const colorArray = new Float32Array(PARTICLE_COUNT * 3);

  for(let i=0; i<PARTICLE_COUNT; i++) {
    // í™”ë©´ ì „ì²´ì— í¼ì ¸ìˆëŠ” ì´ˆê¸° ìƒíƒœ
    const x = (Math.random() - 0.5) * 800;
    const y = (Math.random() - 0.5) * 800;
    const z = (Math.random() - 0.5) * 400;
    
    posArray[i*3] = x;
    posArray[i*3+1] = y;
    posArray[i*3+2] = z;

    particlesData.push({
      ox: x, oy: y, oz: z, // ì›ë˜(í©ì–´ì§„) ìœ„ì¹˜
      tx: x, ty: y, tz: z, // ëª©í‘œ ìœ„ì¹˜ (ì²˜ìŒì—” ìê¸° ìœ„ì¹˜)
      speed: 0.03 + Math.random() * 0.05 // ì´ë™ ì†ë„ ëœë¤
    });

    // ê¸°ë³¸ ìƒ‰ìƒ: ë”¤ ê·¸ë ˆì´
    colorArray[i*3] = 0.3; 
    colorArray[i*3+1] = 0.3; 
    colorArray[i*3+2] = 0.3;
  }

  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
  geometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));

  // ì…ì ì¬ì§ˆ (ë¹›ë‚˜ëŠ” ì )
  const material = new THREE.PointsMaterial({
    size: 2.5,
    vertexColors: true,
    transparent: true,
    opacity: 0.8,
    blending: THREE.AdditiveBlending,
    sizeAttenuation: true
  });

  points = new THREE.Points(geometry, material);
  scene.add(points);

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
}

// ë°ì´í„° ìˆ˜ì‹  í›„ ì…ì ëª©í‘œ ìœ„ì¹˜ ì„¤ì •
function updateParticles(data) {
  if (!data.landmarks || !data.face_rect) return;
  
  hasFace = true;
  currentEmotions = data.emotions;

  const rect = data.face_rect;
  // ì–¼êµ´ ì¤‘ì‹¬ì 
  const centerX = (rect.min_x + rect.max_x) / 2;
  const centerY = (rect.min_y + rect.max_y) / 2;
  
  // ëœë“œë§ˆí¬ ì¢Œí‘œê³„ ë³€í™˜ (ì´ë¯¸ì§€ 2D -> 3D ì›”ë“œ)
  const landmarks3D = data.landmarks.map(lm => {
    return {
      x: (lm.x - centerX) * 1.2,   // ìŠ¤ì¼€ì¼ í‚¤ì›€ (í™”ë©´ì— ê½‰ ì°¨ê²Œ)
      y: -(lm.y - centerY) * 1.2,  // Yì¶• ë°˜ì „
      z: lm.z || 0
    };
  });

  // ì…ìë“¤ì„ ëœë“œë§ˆí¬ ìœ„ì¹˜ë¡œ ë°°ì •
  particlesData.forEach((p, i) => {
    // ëœë“œë§ˆí¬ ê°œìˆ˜ë§Œí¼ ìˆœí™˜í•˜ë©° í• ë‹¹
    const targetLm = landmarks3D[i % landmarks3D.length];
    
    // ëª©í‘œ ìœ„ì¹˜: ëœë“œë§ˆí¬ ê·¼ì²˜ + ì•½ê°„ì˜ ëœë¤ í™•ì‚° (ë©´ì²˜ëŸ¼ ë³´ì´ê²Œ)
    p.tx = targetLm.x + (Math.random() - 0.5) * 10;
    p.ty = targetLm.y + (Math.random() - 0.5) * 10;
    
    // Zì¶•(ê¹Šì´)ì€ ì–¼êµ´ ì…ì²´ê° + ëœë¤
    p.tz = (targetLm.z * 3) + (Math.random() - 0.5) * 10; 
  });
}

// ì–¼êµ´ ì—†ìœ¼ë©´ í©ì–´ì§€ê¸°
function disperseParticles() {
  hasFace = false;
  particlesData.forEach(p => {
    p.tx = p.ox;
    p.ty = p.oy;
    p.tz = p.oz;
  });
}

// ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„
function animate() {
  requestAnimationFrame(animate);

  const positions = points.geometry.attributes.position.array;
  const colors = points.geometry.attributes.color.array;
  
  const { joy, sorrow, anger, surprise } = currentEmotions;
  const time = Date.now() * 0.001;

  // ê°ì •ë³„ ëª©í‘œ ìƒ‰ìƒ
  let tr = 0.5, tg = 0.6, tb = 0.7; // í‰ì†Œ: ì°¨ê°€ìš´ ê¸ˆì†ì„± ëŠë‚Œ
  
  if (hasFace) {
    // ê°ì •ì´ ì„ì„
    if (joy > 0.1) { tr=1.0; tg=0.8; tb=0.2; } // Joy: Gold
    if (anger > 0.1) { tr=1.0; tg=0.1; tb=0.1; } // Anger: Red
    if (sorrow > 0.1) { tr=0.1; tg=0.3; tb=1.0; } // Sorrow: Blue
    if (surprise > 0.1) { tr=1.0; tg=1.0; tb=1.0; } // Surprise: White
  }

  for (let i = 0; i < PARTICLE_COUNT; i++) {
    const p = particlesData[i];
    const idx = i * 3;

    // í˜„ì¬ ìœ„ì¹˜
    let cx = positions[idx];
    let cy = positions[idx+1];
    let cz = positions[idx+2];

    // ëª©í‘œ ìœ„ì¹˜ ê°€ì ¸ì˜¤ê¸°
    let tx = p.tx;
    let ty = p.ty;
    let tz = p.tz;

    // --- [ë¬¼ë¦¬ì  ë³€í˜• íš¨ê³¼] ---
    if (hasFace) {
      // 1. ìŠ¬í””: í˜ëŸ¬ë‚´ë¦¼ (Melt)
      if (sorrow > 0.1) {
        // ì‚¬ì¸íŒŒ ëª¨ì–‘ìœ¼ë¡œ ëšëš ë–¨ì–´ì§
        const drop = Math.abs(Math.sin(time * 2 + cx * 0.05)) * sorrow * 40;
        ty -= drop; 
        p.speed = 0.02; // ë¬´ê²ê²Œ ì›€ì§ì„
      }

      // 2. ê¸°ì¨: ìƒìŠ¹ ë° ë¶€ìœ  (Float)
      if (joy > 0.1) {
        ty += Math.sin(time * 3 + cx * 0.1) * joy * 10;
        tx += Math.cos(time * 2 + cy * 0.1) * joy * 5;
        p.speed = 0.08; // ê°€ë³ê³  ë¹ ë¥´ê²Œ
      }

      // 3. ë¶„ë…¸: ë…¸ì´ì¦ˆ ì§„ë™ (Shake)
      if (anger > 0.1) {
        tx += (Math.random() - 0.5) * anger * 20;
        ty += (Math.random() - 0.5) * anger * 20;
        p.speed = 0.15; // ì•„ì£¼ ë¹ ë¥´ê³  ê±°ì¹ ê²Œ
      }
    }

    // ìœ„ì¹˜ ì—…ë°ì´íŠ¸ (Lerp: í˜„ì¬ -> ëª©í‘œ)
    cx += (tx - cx) * p.speed;
    cy += (ty - cy) * p.speed;
    cz += (tz - cz) * p.speed;

    positions[idx] = cx;
    positions[idx+1] = cy;
    positions[idx+2] = cz;

    // ìƒ‰ìƒ ì—…ë°ì´íŠ¸ (Lerp)
    colors[idx] += (tr - colors[idx]) * 0.05;
    colors[idx+1] += (tg - colors[idx+1]) * 0.05;
    colors[idx+2] += (tb - colors[idx+2]) * 0.05;
  }

  // ì „ì²´ ì”¬ íšŒì „ (ì‚´ì§ì‚´ì§ ì›€ì§ì—¬ ì…ì²´ê° ë¶€ì—¬)
  if (hasFace) {
    // ì–¼êµ´ì´ ìˆì„ ë• ì•„ì£¼ ì²œì²œíˆ ìˆ¨ì‰¬ë“¯
    points.rotation.y = Math.sin(time * 0.5) * 0.05;
  } else {
    // ëŒ€ê¸° ìƒíƒœì—ì„  ì²œì²œíˆ ë”
    points.rotation.y += 0.0005;
  }

  points.geometry.attributes.position.needsUpdate = true;
  points.geometry.attributes.color.needsUpdate = true;

  renderer.render(scene, camera);
}

initThree();
animate();

</script>
</body>
</html>
