<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Emotion Sphere (Google Vision)</title>
  <style>
    /* ================= ê¸°ë³¸ ìŠ¤íƒ€ì¼ ================= */
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden; /* ìŠ¤í¬ë¡¤ ë°©ì§€ */
      background: #000;
      height: 100%;
      font-family: sans-serif;
      /* ë“œë˜ê·¸ ë° ì„ íƒ ë°©ì§€ (í‚¤ì˜¤ìŠ¤í¬ ëª¨ë“œìš©) */
      user-select: none;
      -webkit-user-select: none;
    }
    #container {
      width: 100vw;
      height: 100vh;
      position: absolute;
      top: 0;
      left: 0;
    }

    /* ================= ìƒë‹¨ UI (ì •ë³´ ë° ì œì–´) ================= */
    #ui {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 100; /* Three.js ë³´ë‹¤ ìœ„ì— */
      color: #fff;
      font-size: 14px;
      width: 300px;
      line-height: 1.6;
      background: rgba(0, 0, 0, 0.5); /* ë°°ê²½ ë°˜íˆ¬ëª… */
      padding: 15px;
      border-radius: 12px;
      backdrop-filter: blur(5px); /* ë¸”ëŸ¬ íš¨ê³¼ */
    }
    /* ìƒë‹¨ ì‘ì€ ë²„íŠ¼ë“¤ */
    .control-btn {
      padding: 8px 12px;
      margin-right: 8px;
      margin-bottom: 10px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.3);
      background: rgba(255, 255, 255, 0.2);
      color: #fff;
      font-size: 12px;
      cursor: pointer;
      transition: background 0.3s;
    }
    .control-btn:hover, .control-btn:active {
      background: rgba(255, 255, 255, 0.4);
    }
    #info {
      white-space: pre-wrap; /* ì¤„ë°”ê¿ˆ ë³´ì¡´ */
    }

    /* ================= ìš°ì¸¡ í•˜ë‹¨ ì¹´ë©”ë¼ ì„¹ì…˜ ================= */
    #camera-section {
      position: fixed;
      bottom: 30px;
      right: 30px;
      z-index: 110;
      display: flex;
      flex-direction: column;
      align-items: flex-end; /* ì˜¤ë¥¸ìª½ ì •ë ¬ */
      gap: 15px; /* ë²„íŠ¼ê³¼ ì¹´ë©”ë¼ ì‚¬ì´ ê°„ê²© */
    }

    /* 1) í¬ê³  ì•„ë¦„ë‹¤ìš´ ì´¬ì˜ ë²„íŠ¼ */
    #snapBtn {
      padding: 20px 40px; /* í¬ê¸° ëŒ€í­ í™•ëŒ€ */
      border-radius: 50px; /* ë‘¥ê·¼ ì•Œì•½ ëª¨ì–‘ */
      border: none;
      background: linear-gradient(135deg, #ff6b6b, #f06595); /* ëˆˆì— ë„ëŠ” ê·¸ë¼ë°ì´ì…˜ */
      color: #fff;
      font-size: 24px; /* ê¸€ì í¬ê¸° í™•ëŒ€ */
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
      transition: transform 0.2s, box-shadow 0.2s;
      /* í…ìŠ¤íŠ¸ ì¤„ë°”ê¿ˆ ë°©ì§€ */
      white-space: nowrap;
    }
    #snapBtn:active {
      transform: scale(0.95); /* í´ë¦­ ì‹œ ì‚´ì§ ëˆŒë¦¬ëŠ” íš¨ê³¼ */
      box-shadow: 0 2px 10px rgba(255, 107, 107, 0.4);
      background: linear-gradient(135deg, #fa5252, #e64980);
    }

    /* 2) ì¹´ë©”ë¼ ë˜í¼ (ë¹„ë””ì˜¤ + ê°€ì´ë“œë¼ì¸) */
    #camera-wrapper {
      position: relative;
      width: 400px;  /* ë„ˆë¹„ í™•ëŒ€ */
      height: 300px; /* ë†’ì´ í™•ëŒ€ */
      border-radius: 20px;
      overflow: hidden;
      border: 3px solid rgba(255, 255, 255, 0.5);
      background: #222;
      box-shadow: 0 10px 25px rgba(0,0,0,0.5);
    }

    /* ì‹¤ì œ ë¹„ë””ì˜¤ í™”ë©´ */
    #cam {
      width: 100%;
      height: 100%;
      object-fit: cover; /* í™”ë©´ ê½‰ ì±„ìš°ê¸° */
      transform: scaleX(-1); /* ê±°ìš¸ëª¨ë“œ (ì¢Œìš°ë°˜ì „) */
    }

    /* ì–¼êµ´ ê°€ì´ë“œë¼ì¸ ì˜¤ë²„ë ˆì´ */
    #face-guide {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 45%;  /* ê°€ì´ë“œ ë„ˆë¹„ */
      height: 70%; /* ê°€ì´ë“œ ë†’ì´ */
      border: 4px dashed rgba(255, 255, 255, 0.7); /* ì ì„  í…Œë‘ë¦¬ */
      border-radius: 50% 50% 60% 60%; /* ì•½ê°„ ë‹¬ê±€í˜• íƒ€ì› */
      box-shadow: inset 0 0 20px rgba(0,0,0,0.2);
      pointer-events: none; /* í´ë¦­ í†µê³¼ë˜ë„ë¡ ì„¤ì • */
    }

    /* ìº¡ì³ìš© ìˆ¨ê¹€ ìº”ë²„ìŠ¤ */
    #snap { display: none; }

  </style>
</head>
<body>

<div id="container"></div>

<div id="ui">
  <div>
    <button id="startBtn" class="control-btn">ì¹´ë©”ë¼ ì¼œê¸°</button>
    <button id="stopBtn" class="control-btn">ì¹´ë©”ë¼ ë„ê¸°</button>
  </div>
  <div id="info">ì™¼ìª½ ìœ„ ë²„íŠ¼ìœ¼ë¡œ ì¹´ë©”ë¼ë¥¼ ì¼œì£¼ì„¸ìš”.</div>
</div>

<div id="camera-section">
  <button id="snapBtn">ğŸ“¸ ì‚¬ì§„ ì°ê³  ë¶„ì„í•˜ê¸°</button>
  
  <div id="camera-wrapper">
    <video id="cam" autoplay playsinline muted></video>
    <div id="face-guide"></div> </div>
</div>

<canvas id="snap" width="640" height="480"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
/* ===========================================================
    ì¤‘ìš”: ì„œë²„ ì£¼ì†Œ ì„¤ì •
    (ë‚˜ì¤‘ì— Cloud Run ë°°í¬ í›„ ì—¬ê¸°ì— ì£¼ì†Œë¥¼ ë„£ì–´ì•¼ í•©ë‹ˆë‹¤.)
=========================================================== */
// ì„ì‹œ ì£¼ì†Œ (ë‚˜ì¤‘ì— êµì²´ í•„ìˆ˜)
const SERVER_URL = "https://emotion-server-backend-907115489834.asia-northeast3.run.app/analyze";


/* ===========================================================
    1) ì¹´ë©”ë¼ ì œì–´
=========================================================== */
let stream = null;

async function startCamera() {
  const info = document.getElementById("info");
  const video = document.getElementById("cam");

  try {
    // íƒœë¸”ë¦¿ í›„ë©´ ì¹´ë©”ë¼ ëŒ€ì‹  ì „ë©´(ì…€ì¹´) ì¹´ë©”ë¼ ìš°ì„  ìš”ì²­
    stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: "user", width: 640, height: 480 }
    });
    video.srcObject = stream;
    info.innerHTML = "ì¹´ë©”ë¼ê°€ ì¼œì¡ŒìŠµë‹ˆë‹¤.<br>ê°€ì´ë“œë¼ì¸ì— ì–¼êµ´ì„ ë§ì¶”ê³ <br>ìš°ì¸¡ í•˜ë‹¨ ğŸ“¸ ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”.";
  } catch (e) {
    info.textContent = "ì¹´ë©”ë¼ ì ‘ê·¼ ì‹¤íŒ¨: " + e.message + "\n(HTTPS í™˜ê²½ì¸ì§€ í™•ì¸í•´ì£¼ì„¸ìš”)";
    alert("ì¹´ë©”ë¼ ì ‘ê·¼ ì‹¤íŒ¨. HTTPS ì ‘ì†ì´ í•„ìš”í•©ë‹ˆë‹¤.");
  }
}

function stopCamera() {
  const info = document.getElementById("info");
  const video = document.getElementById("cam");
  if (stream) {
    stream.getTracks().forEach(t => t.stop());
    stream = null;
    video.srcObject = null;
    info.textContent = "ì¹´ë©”ë¼ê°€ êº¼ì¡ŒìŠµë‹ˆë‹¤.";
  }
}


/* ===========================================================
    2) ì‚¬ì§„ ìº¡ì³ â†’ ì„œë²„ ì „ì†¡ â†’ ê²°ê³¼ ì²˜ë¦¬
=========================================================== */
async function snapAndAnalyze() {
  const info = document.getElementById("info");
  const video = document.getElementById("cam");
  const canvas = document.getElementById("snap");
  const ctx = canvas.getContext("2d");
  const snapBtn = document.getElementById("snapBtn");

  if (!stream || !video.srcObject) {
    alert("ë¨¼ì € 'ì¹´ë©”ë¼ ì¼œê¸°'ë¥¼ ëˆŒëŸ¬ì£¼ì„¸ìš”!");
    return;
  }

  // ë²„íŠ¼ ì¤‘ë³µ í´ë¦­ ë°©ì§€ ë° í”¼ë“œë°±
  snapBtn.disabled = true;
  const originalBtnText = snapBtn.innerHTML;
  snapBtn.innerHTML = "â³ ë¶„ì„ ì¤‘...";
  snapBtn.style.background = "#999";

  // ìº”ë²„ìŠ¤ì— í˜„ì¬ ë¹„ë””ì˜¤ í™”ë©´ ê·¸ë¦¬ê¸°
  // (ì¢Œìš°ë°˜ì „ëœ ë¹„ë””ì˜¤ë¥¼ ë‹¤ì‹œ ë°˜ì „ì‹œì¼œì„œ ì •ë°©í–¥ìœ¼ë¡œ ìº¡ì³)
  ctx.save();
  ctx.scale(-1, 1);
  ctx.drawImage(video, -canvas.width, 0, canvas.width, canvas.height);
  ctx.restore();

  info.textContent = "ì´ë¯¸ì§€ ìº¡ì³ ì™„ë£Œ. ì„œë²„ ì „ì†¡ ì¤€ë¹„...";

  canvas.toBlob(async blob => {
    if (!blob) {
      info.textContent = "ì´ë¯¸ì§€ ë³€í™˜ ì‹¤íŒ¨";
      resetButton();
      return;
    }

    info.textContent = "â˜ï¸ ì„œë²„ë¡œ ì´ë¯¸ì§€ ì „ì†¡ ì¤‘...";

    const form = new FormData();
    form.append("frame", blob, "frame.jpg");

    try {
      // 1. ì„œë²„ ìš”ì²­
      const res = await fetch(SERVER_URL, { method: "POST", body: form });

      // 2. ì‘ë‹µ ì²˜ë¦¬
      if (!res.ok) throw new Error(`ì„œë²„ ì˜¤ë¥˜ (HTTP ${res.status})`);
      
      const data = await res.json(); // ë°”ë¡œ JSONìœ¼ë¡œ íŒŒì‹±

      if (data.status !== "ok") {
        throw new Error(data.error || data.detail || "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜");
      }

      // 3. ì„±ê³µ ì‹œ ì •ë³´ í‘œì‹œ ë° êµ¬ ì—…ë°ì´íŠ¸
      info.innerHTML = "âœ… ë¶„ì„ ì„±ê³µ!\n" +
                       "ê°ì • ê²°ê³¼ê°€ êµ¬ì— ë°˜ì˜ë˜ì—ˆìŠµë‹ˆë‹¤.\n\n" +
                       JSON.stringify(data.emotions, null, 2);

      updateSphereFromEmotion(data);

    } catch (err) {
      console.error(err);
      info.textContent = "âŒ ë¶„ì„ ì‹¤íŒ¨:\n" + err.message;
      // ì•„ì§ ì„œë²„ê°€ ì—†ì„ ë•Œë¥¼ ìœ„í•œ ì•ˆë‚´
      if(err.message.includes("Failed to fetch")) {
        info.textContent += "\n\n(í˜„ì¬ ì„œë²„ ì£¼ì†Œê°€ ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.\nHTML ì½”ë“œì˜ SERVER_URLì„ í™•ì¸í•´ì£¼ì„¸ìš”.)";
      }
    } finally {
      // ë²„íŠ¼ ìƒíƒœ ë³µêµ¬
      resetButton();
    }
  }, "image/jpeg", 0.95);

  function resetButton() {
    snapBtn.disabled = false;
    snapBtn.innerHTML = originalBtnText;
    snapBtn.style.background = ""; // ì›ë˜ ê·¸ë¼ë°ì´ì…˜ìœ¼ë¡œ ë³µê·€
  }
}

// ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
document.getElementById("startBtn").addEventListener("click", startCamera);
document.getElementById("stopBtn").addEventListener("click", stopCamera);
document.getElementById("snapBtn").addEventListener("click", snapAndAnalyze);


/* ===========================================================
    3) Three.js: "Digital Entropy (ë””ì§€í„¸ ì—”íŠ¸ë¡œí”¼)"
    - AI í•´ì„: ê°ì •ì€ ì™„ë²½í•œ ë°ì´í„° êµ¬ì¡°(ì§ˆì„œ)ë¥¼ ë¬´ë„ˆëœ¨ë¦¬ëŠ” ë…¸ì´ì¦ˆ(í˜¼ëˆ)ë‹¤.
=========================================================== */
let scene, camera, renderer, geometry, points;
let basePositions = []; 

// ëª©í‘œ ê°ì • ìƒíƒœ
let targetEmotions = { joy: 0, sorrow: 0, anger: 0, surprise: 0, arousal: 0 };
let currentEmotions = { joy: 0, sorrow: 0, anger: 0, surprise: 0, arousal: 0 };

function initThree() {
  const container = document.getElementById("container");
  scene = new THREE.Scene();
  // ë°°ê²½: ì™„ì „í•œ ë””ì§€í„¸ ë¸”ë™
  scene.background = new THREE.Color(0x000000); 

  const W = window.innerWidth;
  const H = window.innerHeight;

  camera = new THREE.PerspectiveCamera(45, W / H, 0.1, 100);
  camera.position.set(0, 0, 8); 

  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(W, H);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  container.appendChild(renderer.domElement);

  // ì…ì ìƒì„±: ì§ˆì„œì •ì—°í•œ ëŠë‚Œì„ ìœ„í•´ ì ì˜ ê°œìˆ˜ë¥¼ ì ë‹¹íˆ ìœ ì§€í•˜ë˜ í¬ê²Œ
  const count = 4000;
  const positions = new Float32Array(count * 3);
  const colors = new Float32Array(count * 3);
  const sizes = new Float32Array(count); // ì…ì í¬ê¸°ë„ ê°œë³„ ì œì–´
  const R = 2.0; 

  basePositions = [];

  for (let i = 0; i < count; i++) {
    // 1. ì´ˆê¸° ìƒíƒœ: ì™„ë²½í•œ ìˆ˜í•™ì  êµ¬ (ì§ˆì„œ)
    // Fibonacci Sphere ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ê· ì¼í•˜ê²Œ ë°°ì¹˜
    const goldenRatio = (1 + Math.sqrt(5)) / 2;
    const theta = 2 * Math.PI * i / goldenRatio;
    const phi = Math.acos(1 - 2 * (i + 0.5) / count);

    const x = R * Math.sin(phi) * Math.cos(theta);
    const y = R * Math.sin(phi) * Math.sin(theta);
    const z = R * Math.cos(phi);

    positions[i * 3] = x;
    positions[i * 3 + 1] = y;
    positions[i * 3 + 2] = z;

    basePositions.push({x, y, z});

    // ìƒ‰ìƒ: AIì˜ ê¸°ë³¸ ì»¬ëŸ¬ = Cyan / Electric Blue
    colors[i * 3] = 0.0;
    colors[i * 3 + 1] = 1.0;
    colors[i * 3 + 2] = 1.0;
    
    sizes[i] = 1.0;
  }

  geometry = new THREE.BufferGeometry();
  geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
  geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));
  geometry.setAttribute("size", new THREE.BufferAttribute(sizes, 1));

  // ì‰ì´ë” ëŠë‚Œì˜ ì¬ì§ˆ
  const material = new THREE.PointsMaterial({
    size: 0.03,
    vertexColors: true,
    transparent: true,
    opacity: 0.9,
    blending: THREE.AdditiveBlending,
    sizeAttenuation: true
  });

  points = new THREE.Points(geometry, material);
  scene.add(points);

  window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
}

function lerp(start, end, t) {
  return start * (1 - t) + end * t;
}

function animate() {
  requestAnimationFrame(animate);

  if (!points) return;

  // ê°ì • ìƒíƒœ ì—…ë°ì´íŠ¸ (ë°˜ì‘ ì†ë„: 0.08 - ê¸°ê³„ì ìœ¼ë¡œ ë¹ ë¦¿í•˜ê²Œ)
  const speed = 0.08;
  currentEmotions.joy = lerp(currentEmotions.joy, targetEmotions.joy, speed);
  currentEmotions.sorrow = lerp(currentEmotions.sorrow, targetEmotions.sorrow, speed);
  currentEmotions.anger = lerp(currentEmotions.anger, targetEmotions.anger, speed);
  currentEmotions.surprise = lerp(currentEmotions.surprise, targetEmotions.surprise, speed);
  currentEmotions.arousal = lerp(currentEmotions.arousal, targetEmotions.arousal, speed);

  const positions = geometry.attributes.position.array;
  const colors = geometry.attributes.color.array;
  
  // ì‹œê°„ ë³€ìˆ˜
  const time = performance.now() * 0.001;
  
  const joy = currentEmotions.joy;
  const sorrow = currentEmotions.sorrow;
  const anger = currentEmotions.anger;
  const surprise = currentEmotions.surprise;
  const arousal = currentEmotions.arousal;

  // ê¸°ë³¸ íšŒì „: ê¸°ê³„ì ì¸ ë“±ì† íšŒì „
  points.rotation.y = time * 0.2;
  
  // ë¶„ë…¸ ì‹œ íšŒì „ì´ ëšëš ëŠê¹€ (Lag í˜„ìƒ)
  if (Math.random() < anger * 0.3) {
      points.rotation.y += (Math.random() - 0.5) * 0.5;
      points.rotation.x += (Math.random() - 0.5) * 0.5;
  }

  for (let i = 0; i < basePositions.length; i++) {
    const base = basePositions[i];
    const idx = i * 3;

    let nx = base.x;
    let ny = base.y;
    let nz = base.z;

    // --- [1. AIì˜ ê°ì • í•´ì„: ë°ì´í„° ë³€í˜•] ---

    // A. ê¸°ì¨ (Joy) = ë°ì´í„° í™•ì¥ ë° ìˆœí™˜ (Processing Power Increase)
    // êµ¬ê°€ ì»¤ì§€ë©´ì„œ ì‚¬ì¸íŒŒ í˜•íƒœë¡œ ë¶€ë“œëŸ½ê²Œ ë¬¼ê²°ì¹¨ (ì•ˆì •ì ì¸ ì˜¤ë²„í´ëŸ­)
    const joyWave = Math.sin(time * 3 + base.y * 2) * joy * 0.5;
    const joyExpand = 1.0 + (joy * 0.5);
    
    // B. ë¶„ë…¸ (Anger) = ê¸€ë¦¬ì¹˜ ë…¸ì´ì¦ˆ (System Instability)
    // ì…ìë“¤ì´ ëœë¤í•˜ê²Œ íŠ€ì–´ ë‚˜ê° (ê³ ì£¼íŒŒ ë…¸ì´ì¦ˆ)
    // Math.random()ì„ ë§¤ í”„ë ˆì„ í˜¸ì¶œí•˜ë©´ ì§€ì§ê±°ë¦¬ëŠ” íš¨ê³¼ ë‚¨
    const glitchX = (Math.random() - 0.5) * anger * 0.6;
    const glitchY = (Math.random() - 0.5) * anger * 0.6;
    const glitchZ = (Math.random() - 0.5) * anger * 0.6;

    // C. ìŠ¬í”” (Sorrow) = ë°ì´í„° ì••ì¶• ë° ì†Œì‹¤ (Signal Loss)
    // êµ¬ê°€ ì°Œê·¸ëŸ¬ì§€ê³ (ë‚©ì‘í•´ì§) ì…ìë“¤ì´ ì¤‘ì‹¬ì´ë‚˜ ë°”ë‹¥ìœ¼ë¡œ êº¼ì§
    const collapse = 1.0 - (sorrow * 0.6);
    
    // D. ë†€ëŒ (Surprise) = ì‚°ë€ (Scattering)
    // ì…ìë“¤ì´ ë°–ìœ¼ë¡œ í™• í©ì–´ì§
    const scatter = surprise * Math.sin(time * 10 + i) * 0.3;

    // ì¢Œí‘œ í•©ì„±
    // 1. ê¸°ì¨(í™•ì¥)ê³¼ ìŠ¬í””(ì¶•ì†Œ) ì ìš©
    nx *= joyExpand * collapse;
    ny *= joyExpand * collapse;
    nz *= joyExpand * collapse;

    // 2. ê¸°ì¨ì˜ ë¬¼ê²° ì¶”ê°€ (ë°©í–¥ì„± ìˆê²Œ)
    nx += base.x * joyWave;
    ny += base.y * joyWave;
    nz += base.z * joyWave;

    // 3. ë¶„ë…¸ì˜ ê¸€ë¦¬ì¹˜(ë…¸ì´ì¦ˆ)ëŠ” ì¢Œí‘œ ìì²´ë¥¼ ë’¤í”ë“¦
    nx += glitchX + scatter;
    ny += glitchY + scatter;
    nz += glitchZ + scatter;

    // ìŠ¬í””ì¼ ë•Œ yì¶• ë°ì´í„°ê°€ ë°”ë‹¥ìœ¼ë¡œ íë¦„ (í˜ëŸ¬ë‚´ë¦¬ëŠ” ë°ì´í„°)
    if (sorrow > 0.1) {
        ny -= Math.abs(Math.sin(time * 0.5 + base.x)) * sorrow * 1.5;
    }

    positions[idx] = nx;
    positions[idx + 1] = ny;
    positions[idx + 2] = nz;


    // --- [2. ìƒ‰ìƒ: ì‹œìŠ¤í…œ ìƒíƒœ í‘œì‹œ] ---

    // ê¸°ë³¸ìƒ‰: Cyan (0, 1, 1) - ì •ìƒ ì‘ë™ ì¤‘
    let r = 0.0;
    let g = 1.0;
    let b = 1.0;

    if (joy > 0.1) {
        // ê¸°ì¨: High Performance Mode (Magenta/Pink)
        // Cyanê³¼ ì„ì´ë©´ì„œ íŒŒìŠ¤í…” í†¤ì˜ í™”ë ¤í•œ ìƒ‰ì´ ë¨
        r += joy * 1.0; 
        g -= joy * 0.5; // Greenì„ ë¹¼ì„œ Pinkë¡œ
    }
    
    if (anger > 0.1) {
        // ë¶„ë…¸: Critical Error (Red/Orange)
        // ê°•ë ¬í•˜ê²Œ ê¹œë¹¡ê±°ë¦¼
        const flash = Math.sin(time * 30) > 0 ? 1 : 0.5; // ê¹œë¹¡ì„
        r += anger * 1.0 * flash;
        g -= anger * 1.0;
        b -= anger * 1.0;
    }

    if (sorrow > 0.1) {
        // ìŠ¬í””: Power Saving / Dim (Dark Blue/Grey)
        // ë¹›ì´ êº¼ì ¸ê°€ëŠ” ëŠë‚Œ
        r = 0.1;
        g = 0.1 + (1 - sorrow) * 0.5;
        b = 0.3 + (1 - sorrow) * 0.7;
    }
    
    if (surprise > 0.1) {
        // ë†€ëŒ: White Flash (Overexposure)
        // ëª¨ë“  ìƒ‰ìƒì´ ìµœëŒ€ì¹˜ë¡œ
        r += surprise;
        g += surprise;
        b += surprise;
    }

    // í¥ë¶„ë„(Arousal)ê°€ ë†’ìœ¼ë©´ ì „ì²´ ë°ê¸°(Intensity) ì¦ê°€
    r += arousal * 0.2;
    g += arousal * 0.2;
    b += arousal * 0.2;

    colors[idx] = Math.min(1, Math.max(0, r));
    colors[idx + 1] = Math.min(1, Math.max(0, g));
    colors[idx + 2] = Math.min(1, Math.max(0, b));
  }

  geometry.attributes.position.needsUpdate = true;
  geometry.attributes.color.needsUpdate = true;
  
  renderer.render(scene, camera);
}

/* ===========================================================
    4) ë°ì´í„° ìˆ˜ì‹ ë¶€ (ì„œë²„ì—ì„œ ë°›ì€ ê°’ì„ ëª©í‘œì¹˜ë¡œ ì„¤ì •)
=========================================================== */
function updateSphereFromEmotion(data) {
  if (!data.emotions) return;
  const e = data.emotions;
  
  targetEmotions.joy = e.joy || 0;
  targetEmotions.sorrow = e.sorrow || 0;
  targetEmotions.anger = e.anger || 0;
  targetEmotions.surprise = e.surprise || 0;
  targetEmotions.arousal = (data.arousal || 0) * 0.5; 
  
  console.log("AI State Updated:", targetEmotions);
}

initThree();
animate();


  
</script>
</body>
</html>



