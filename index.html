<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Digital Aura Exhibition</title>
  <style>
    /* 기본 설정 */
    body { margin: 0; overflow: hidden; background: #000; font-family: 'Pretendard', sans-serif; user-select: none; }
    
    /* Three.js 배경 (가장 뒤) */
    #container { position: absolute; width: 100%; height: 100%; top: 0; left: 0; z-index: 0; }
    
    /* 공통 UI 스타일 */
    .screen {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      transition: opacity 0.5s ease;
      z-index: 10;
      pointer-events: none; /* 배경 터치 통과 */
    }
    .screen.hidden { opacity: 0; pointer-events: none; display: none; } /* display: none 추가 */
    .screen.active { opacity: 1; pointer-events: auto; display: flex; }

    /* 버튼 스타일 */
    button {
      padding: 15px 40px;
      border: 1px solid rgba(255, 255, 255, 0.4);
      background: rgba(0, 0, 0, 0.5);
      color: #fff; font-size: 16px; letter-spacing: 2px;
      cursor: pointer; border-radius: 4px;
      backdrop-filter: blur(5px);
      transition: all 0.3s;
      pointer-events: auto;
      text-transform: uppercase;
    }
    button:hover { background: rgba(255, 255, 255, 0.2); border-color: #fff; }
    button:active { transform: scale(0.95); }


    /* 1. 대기 화면 (Start Screen) */
    #start-screen { z-index: 30; background: #000; } 
    #startBtn {
      border: none; background: transparent;
      font-size: 24px; letter-spacing: 5px;
      animation: pulse 2s infinite;
    }
    @keyframes pulse { 0% { opacity: 0.4; } 50% { opacity: 1; } 100% { opacity: 0.4; } }


    /* 2. 카메라 화면 (Camera Screen) */
    #camera-screen {
      justify-content: flex-end; padding-bottom: 60px;
      background: rgba(0,0,0,0.3); /* 배경 살짝 어둡게 */
    }

    #camera-frame {
      position: absolute; top: 50%; left: 50%;
      transform: translate(-50%, -60%);
      width: 300px; height: 300px; /* 네모난 모양 */
      border: 1px solid rgba(255, 255, 255, 0.3);
      background: #000;
      overflow: hidden;
      box-shadow: 0 0 50px rgba(0,0,0,0.5);
    }

    #cam {
      width: 100%; height: 100%;
      object-fit: cover;
      transform: scaleX(-1); /* 거울모드 */
      opacity: 0.9;
    }

    /* 얼굴 가이드 (네모 안의 타원) */
    #face-guide {
      position: absolute; top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      width: 60%; height: 70%;
      border: 2px dashed rgba(255, 255, 255, 0.5);
      border-radius: 50%;
      box-shadow: 0 0 0 100vmax rgba(0,0,0,0.5); 
    }

    #scanBtn {
      margin-top: 20px; font-weight: bold; background: #fff; color: #000; border: none;
      z-index: 50; /* 버튼이 확실히 위에 오도록 */
    }


    /* 3. 결과/다시하기 화면 (Retry Screen) */
    #retry-screen {
      justify-content: flex-end; padding-bottom: 60px;
    }
    #info-text {
      position: absolute; top: 15%; width: 100%;
      text-align: center; color: rgba(255,255,255,0.7);
      font-size: 16px; letter-spacing: 1px;
    }

    #snap { display: none; }
  </style>
</head>
<body>

<div id="container"></div>

<div id="start-screen" class="screen active">
  <button id="startBtn">TOUCH TO START</button>
</div>

<div id="camera-screen" class="screen hidden">
  <div id="camera-frame">
    <video id="cam" autoplay playsinline muted></video>
    <div id="face-guide"></div>
  </div>
  <button id="scanBtn">SCAN</button>
</div>

<div id="retry-screen" class="screen hidden">
  <div id="info-text">데이터를 해석하고 있습니다...</div>
  <button id="retryBtn">↺ RE-SCAN</button>
</div>

<canvas id="snap" width="640" height="480"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/josephg/noisejs/perlin.js"></script>

<script>
// [서버 주소]
const SERVER_URL = "https://emotion-server-backend-907115489834.asia-northeast3.run.app/analyze";

/* ================= [1] 상태 관리 및 시퀀스 로직 ================= */
const startScreen = document.getElementById("start-screen");
const cameraScreen = document.getElementById("camera-screen");
const retryScreen = document.getElementById("retry-screen");

const startBtn = document.getElementById("startBtn");
const scanBtn = document.getElementById("scanBtn");
const retryBtn = document.getElementById("retryBtn");
const infoText = document.getElementById("info-text");

const videoElement = document.getElementById("cam");
let stream = null;
let idleTimer = null;
const IDLE_LIMIT = 60000; // 1분

// 1. 접속하자마자 카메라 권한 요청
async function initCamera() {
  try {
    console.log("Requesting Camera...");
    stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: "user", width: 640, height: 480 }
    });
    videoElement.srcObject = stream;
    await videoElement.play();
    console.log("Camera started in background.");
  } catch (e) {
    console.warn("Autoplay blocked or permission denied. Waiting for user gesture.", e);
  }
}

window.addEventListener("load", initCamera);

// 2. [TOUCH TO START]
startBtn.addEventListener("click", async () => {
  if (!stream) {
    await initCamera();
  }
  showScreen(cameraScreen);
  resetIdleTimer();
});

// 3. [SCAN]
scanBtn.addEventListener("click", async () => {
  console.log("Scan button clicked");

  if (!stream) {
    await initCamera();
    if (!stream) {
      alert("카메라 오류. 새로고침 해주세요.");
      return;
    }
  }

  resetIdleTimer();

  // UI 전환
  showScreen(null);
  retryScreen.classList.remove("hidden");
  retryScreen.classList.add("active");
  retryBtn.style.display = "none";
  infoText.textContent = "에너지를 해석하고 있습니다...";

  setAnalyzingState(true);

  const canvas = document.getElementById("snap");
  const ctx = canvas.getContext("2d");

  if (videoElement.videoWidth > 0) {
    canvas.width = videoElement.videoWidth;
    canvas.height = videoElement.videoHeight;
  }

  // 좌우반전 캡처
  ctx.save();
  ctx.scale(-1, 1);
  ctx.drawImage(videoElement, -canvas.width, 0, canvas.width, canvas.height);
  ctx.restore();

  canvas.toBlob(async blob => {
    const form = new FormData();
    form.append("frame", blob, "frame.jpg");

    try {
      console.log("Sending to server...");
      const res = await fetch(SERVER_URL, { method: "POST", body: form });
      if (!res.ok) throw new Error("Server Error");
      const data = await res.json();
      console.log("Data received:", data);

      if (data.status === "ok") {
        infoText.textContent = "";
        updateEmotionShape(data); // ← 여기서 형상 업데이트
      } else {
        infoText.textContent = "인식된 얼굴이 없습니다.";
        resetEmotion(false);
      }
    } catch (e) {
      console.error(e);
      infoText.textContent = "서버 연결 실패";
      resetEmotion(false);
    } finally {
      setAnalyzingState(false);
      setTimeout(() => {
        retryBtn.style.display = "block";
      }, 2000);
    }
  }, "image/jpeg", 0.9);
});

// 4. [RE-SCAN]
retryBtn.addEventListener("click", () => {
  resetIdleTimer();
  showScreen(cameraScreen);
  setBackgroundState();
  if (videoElement.paused) videoElement.play();
});

// 5. 자동 초기화
function resetIdleTimer() {
  if (idleTimer) clearTimeout(idleTimer);
  idleTimer = setTimeout(() => {
    console.log("Timeout -> Reset to Start Screen");
    showScreen(startScreen);
    resetEmotion(true);
    stopIdleTimer();
  }, IDLE_LIMIT);
}
function stopIdleTimer() {
  if (idleTimer) clearTimeout(idleTimer);
  idleTimer = null;
}

function showScreen(target) {
  [startScreen, cameraScreen, retryScreen].forEach(s => {
    s.classList.remove("active");
    s.classList.add("hidden");
  });
  if (target) {
    target.classList.remove("hidden");
    target.classList.add("active");
  }
}

// 인터랙션 감지
window.addEventListener("touchstart", () => {
  if (!startScreen.classList.contains("active")) resetIdleTimer();
});
window.addEventListener("click", () => {
  if (!startScreen.classList.contains("active")) resetIdleTimer();
});


/* ================= [2] 감정 → 추상 형상(Emotion Creature) Canvas ================= */

// #container 안에 풀스크린 캔버스 하나 추가
const container = document.getElementById("container");
const emotionCanvas = document.createElement("canvas");
emotionCanvas.id = "emotionCanvas";
emotionCanvas.style.position = "absolute";
emotionCanvas.style.top = "0";
emotionCanvas.style.left = "0";
emotionCanvas.style.width = "100%";
emotionCanvas.style.height = "100%";
emotionCanvas.style.pointerEvents = "none"; // 터치 방해 X
container.appendChild(emotionCanvas);

const ectx = emotionCanvas.getContext("2d");
let cw = 0;
let ch = 0;

function resizeEmotionCanvas() {
  const dpr = window.devicePixelRatio || 1;
  const rect = container.getBoundingClientRect();
  cw = rect.width;
  ch = rect.height;
  emotionCanvas.width = rect.width * dpr;
  emotionCanvas.height = rect.height * dpr;
  ectx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
window.addEventListener("resize", resizeEmotionCanvas);
resizeEmotionCanvas();

let currentEmotion = {
  joy: 0,
  sorrow: 0,
  anger: 0,
  surprise: 0,
  valence: 0,
  energy: 0,
  tension: 0,
  instability: 0
};

let targetEmotion = { ...currentEmotion };
let analyzing = false;
let lastTime = 0;

function lerp(a, b, t) { return a + (b - a) * t; }

// 원시 감정값 → 조합된 지표 + 정제
function processEmotions(raw) {
  let joy = raw.joy ?? 0;
  let sorrow = raw.sorrow ?? 0;
  let anger = raw.anger ?? 0;
  let surprise = raw.surprise ?? 0;

  // 혹시 0~3 같은 값이면 0~1로 스케일링
  const maxRaw = Math.max(joy, sorrow, anger, surprise, 1);
  if (maxRaw > 1.0) {
    joy /= maxRaw;
    sorrow /= maxRaw;
    anger /= maxRaw;
    surprise /= maxRaw;
  }

  // 아주 작은 노이즈는 제거
  const noiseCut = 0.08;
  if (joy < noiseCut) joy = 0;
  if (sorrow < noiseCut) sorrow = 0;
  if (anger < noiseCut) anger = 0;
  if (surprise < noiseCut) surprise = 0;

  // 다시 normalize
  const sum = joy + sorrow + anger + surprise;
  if (sum > 0) {
    joy /= sum;
    sorrow /= sum;
    anger /= sum;
    surprise /= sum;
  }

  const energy = sum > 0 ? Math.max(joy, sorrow, anger, surprise) : 0;  // 전체 강도
  const valence = joy - sorrow;        // +면 밝음, -면 어두움
  const tension = anger;              // 분노 → 날카로움
  const instability = surprise;       // 놀람 → 불안정, 들쑥날쑥

  return { joy, sorrow, anger, surprise, valence, energy, tension, instability };
}

// 서버에서 온 감정 → 타겟 업데이트
function updateEmotionShape(data) {
  if (!data.emotions) return;
  targetEmotion = processEmotions(data.emotions);

  // 감정이 거의 없으면 아주 작은 에너지만 남김
  if (targetEmotion.energy < 0.15) {
    targetEmotion.energy = 0.0;
  }
}

// 분석 중
function setAnalyzingState(isAnalyzing) { analyzing = isAnalyzing; }

// 카메라 화면으로 돌아갈 때 살짝 잔상만 남기고 약하게
function setBackgroundState() {
  targetEmotion.energy *= 0.4;
}

// 리셋
function resetEmotion(fully) {
  if (fully) {
    targetEmotion = {
      joy: 0,
      sorrow: 0,
      anger: 0,
      surprise: 0,
      valence: 0,
      energy: 0,
      tension: 0,
      instability: 0
    };
  } else {
    targetEmotion.energy *= 0.2;
  }
}

// 색 보간용
function mixColor(c1, c2, t) {
  const r = Math.round(c1[0] + (c2[0] - c1[0]) * t);
  const g = Math.round(c1[1] + (c2[1] - c1[1]) * t);
  const b = Math.round(c1[2] + (c2[2] - c1[2]) * t);
  return `rgb(${r},${g},${b})`;
}

// 메인 그리기
function drawEmotionCreature(dt) {
  const t = Math.min(dt * 0.004, 0.25); // 보간 속도

  // 현재 감정을 타겟으로 부드럽게 이동
  currentEmotion.joy        = lerp(currentEmotion.joy,        targetEmotion.joy,        t);
  currentEmotion.sorrow     = lerp(currentEmotion.sorrow,     targetEmotion.sorrow,     t);
  currentEmotion.anger      = lerp(currentEmotion.anger,      targetEmotion.anger,      t);
  currentEmotion.surprise   = lerp(currentEmotion.surprise,   targetEmotion.surprise,   t);
  currentEmotion.valence    = lerp(currentEmotion.valence,    targetEmotion.valence,    t);
  currentEmotion.energy     = lerp(currentEmotion.energy,     targetEmotion.energy,     t);
  currentEmotion.tension    = lerp(currentEmotion.tension,    targetEmotion.tension,    t);
  currentEmotion.instability= lerp(currentEmotion.instability,targetEmotion.instability,t);

  const w = cw;
  const h = ch;
  if (!w || !h) return;

  const time = performance.now() * 0.001;

  // 배경
  ectx.clearRect(0, 0, w, h);
  const bgGrad = ectx.createRadialGradient(
    w/2, h*0.4, 0,
    w/2, h*0.4, Math.max(w,h)*0.7
  );
  bgGrad.addColorStop(0, "rgba(0,0,0,0.0)");
  bgGrad.addColorStop(1, "rgba(0,0,0,0.95)");
  ectx.fillStyle = bgGrad;
  ectx.fillRect(0,0,w,h);

  const cx = w / 2;
  const cy = h * 0.42;

  // 감정 기반 파라미터들
  const E  = currentEmotion.energy;     // 전체 세기 (0~1)
  const V  = currentEmotion.valence;    // -1~1 : 음/양
  const Tn = currentEmotion.tension;    // 0~1 : 뾰족함
  const In = currentEmotion.instability;// 0~1 : 흔들림

  const baseR = Math.min(w,h) * (0.12 + 0.18*E); // 전체 크기
  const lobes = 3 + Math.round( In * 5 );        // 3~8개 "꽃잎"
  const spikiness = 0.2 + Tn * 0.9;              // 분노 많을수록 더 스파이크
  const wobbleAmp = 0.08 + In * 0.25;            // 놀람 많을수록 파형이 요동
  const asymX = V * 0.6;                         // 즐거움-슬픔 비대칭
  const asymY = currentEmotion.sorrow * 0.7;     // 슬픔 많을수록 아래로 쳐짐
  const breathing = Math.sin(time*1.2) * (0.05 + E*0.15);

  // 색: joy(노랑), sorrow(파랑), anger(빨강), surprise(흰색)의 비율로 섞기
  const cJoy = [255, 210, 90];
  const cSor = [90, 140, 255];
  const cAng = [255, 80, 80];
  const cSur = [255,255,255];

  const totalW = currentEmotion.joy + currentEmotion.sorrow + currentEmotion.anger + currentEmotion.surprise || 1;
  const wJoy = currentEmotion.joy      / totalW;
  const wSor = currentEmotion.sorrow   / totalW;
  const wAng = currentEmotion.anger    / totalW;
  const wSur = currentEmotion.surprise / totalW;

  const mixedColor = [
    cJoy[0]*wJoy + cSor[0]*wSor + cAng[0]*wAng + cSur[0]*wSur,
    cJoy[1]*wJoy + cSor[1]*wSor + cAng[1]*wAng + cSur[1]*wSur,
    cJoy[2]*wJoy + cSor[2]*wSor + cAng[2]*wAng + cSur[2]*wSur
  ];

  // 살짝 desaturate + 어둡게
  const baseColor = [
    mixedColor[0]*0.9,
    mixedColor[1]*0.9,
    mixedColor[2]*0.9
  ];

  // 형상 그리기 (polar curve)
  ectx.save();
  ectx.translate(cx, cy);

  // 분석 중에는 살짝 회전
  const rot = analyzing ? time*1.5 : 0;
  ectx.rotate(rot);

  ectx.beginPath();
  const steps = 260;
  for (let i=0; i<=steps; i++) {
    const tRatio = i/steps;
    const theta = tRatio * Math.PI*2;

    // 기본 반경 + 감정 기반 변동
    const lobeTerm = Math.cos(lobes*theta + V*1.5 + time*0.7*In);
    const wobble   = Math.sin(theta*2 + time*1.3) * wobbleAmp;
    let r = baseR * (1 + spikiness*lobeTerm + wobble + breathing);

    // 비대칭 (valence / sorrow)
    const ax = 1 + asymX * Math.cos(theta);
    const ay = 1 + asymY * Math.sin(theta - Math.PI/2);

    const x = Math.cos(theta)*r*ax;
    const y = Math.sin(theta)*r*ay + asymY*baseR*0.5;

    if (i===0) ectx.moveTo(x,y);
    else ectx.lineTo(x,y);
  }
  ectx.closePath();

  // 안쪽에서 바깥쪽으로 색 그라데이션
  const grad = ectx.createRadialGradient(0,0,baseR*0.2, 0,0,baseR*1.4);
  grad.addColorStop(0, `rgba(${baseColor[0]},${baseColor[1]},${baseColor[2]},${0.9*Math.max(E,0.2)})`);
  grad.addColorStop(1, `rgba(${baseColor[0]*0.3},${baseColor[1]*0.3},${baseColor[2]*0.4},0)`);

  ectx.fillStyle = grad;
  ectx.fill();

  // 윤곽선: 분노 많을수록 두껍고 거칠게
  ectx.lineWidth = 1 + Tn*4;
  ectx.strokeStyle = `rgba(255,255,255,${0.25+Tn*0.5})`;
  ectx.stroke();

  // 경계에 점/가시 표현 (분노, 놀람 조합)
  const edgeCount = Math.round(80 + 120*(Tn+In)*0.5);
  ectx.lineWidth = 0;
  for (let i=0; i<edgeCount; i++) {
    const tt = i/edgeCount;
    const theta = tt * Math.PI*2;

    const lobeTerm = Math.cos(lobes*theta + V*1.5 + time*0.7*In);
    const wobble   = Math.sin(theta*2 + time*1.3) * wobbleAmp;
    let r = baseR * (1 + spikiness*lobeTerm + wobble + breathing);

    const ax = 1 + asymX * Math.cos(theta);
    const ay = 1 + asymY * Math.sin(theta - Math.PI/2);

    const x = Math.cos(theta)*r*ax;
    const y = Math.sin(theta)*r*ay + asymY*baseR*0.5;

    const spike = 1 + (Tn*0.9 + In*0.4)*Math.random();
    const sx = x * spike;
    const sy = y * spike;

    const dotAlpha = 0.15 + 0.35*(Tn + In)*0.5;
    ectx.fillStyle = `rgba(255,255,255,${dotAlpha})`;
    ectx.beginPath();
    ectx.arc(sx, sy, 1.2 + 2.5*Tn, 0, Math.PI*2);
    ectx.fill();
  }

  // "눈" 같은 핵심 포인트 (사람이 얼굴처럼 느끼도록 살짝 힌트)
  const eyeOffsetY = -baseR*0.15;
  const eyeSpread  = baseR*0.35*(1+In*0.3);

  const eyeSize = 4 + 10*E;
  const innerGlow = 0.3 + E*0.5;

  ectx.fillStyle = "rgba(0,0,0,0.8)";
  ectx.beginPath();
  ectx.arc(-eyeSpread, eyeOffsetY, eyeSize, 0, Math.PI*2);
  ectx.arc( eyeSpread, eyeOffsetY, eyeSize, 0, Math.PI*2);
  ectx.fill();

  ectx.fillStyle = `rgba(255,255,255,${innerGlow})`;
  ectx.beginPath();
  ectx.arc(-eyeSpread-eyeSize*0.2, eyeOffsetY-eyeSize*0.1, eyeSize*0.35, 0, Math.PI*2);
  ectx.arc( eyeSpread-eyeSize*0.2,  eyeOffsetY-eyeSize*0.1, eyeSize*0.35, 0, Math.PI*2);
  ectx.fill();

  // 아래쪽에 "입"처럼 보이는 곡선 (valence에 따라 모양 바뀜)
  const mouthWidth = baseR*0.7;
  const mouthY = baseR*0.25 + asymY*baseR*0.2;
  const smile = V; // 양수면 웃고, 음수면 처짐

  ectx.beginPath();
  ectx.moveTo(-mouthWidth*0.6, mouthY);
  ectx.quadraticCurveTo(
    0,
    mouthY + baseR*0.25*smile,
    mouthWidth*0.6,
    mouthY
  );
  ectx.strokeStyle = `rgba(255,255,255,${0.25 + 0.3*Math.abs(V)})`;
  ectx.lineWidth = 1.2 + 2*Math.abs(V);
  ectx.stroke();

  ectx.restore();

  // 아래에 아주 작은 텍스트 힌트 (선택사항)
  ectx.font = "11px Pretendard, system-ui, sans-serif";
  ectx.textAlign = "center";
  ectx.textBaseline = "middle";
  ectx.fillStyle = "rgba(255,255,255,0.45)";

  let text = "";
  if (E < 0.05) {
    text = "AI가 감정을 거의 감지하지 못했습니다.";
  } else {
    const pieces = [];
    if (currentEmotion.joy > 0.25)    pieces.push("기쁨");
    if (currentEmotion.sorrow > 0.25) pieces.push("슬픔");
    if (currentEmotion.anger > 0.25)  pieces.push("분노");
    if (currentEmotion.surprise > 0.25) pieces.push("놀람");

    if (pieces.length === 0) {
      text = "애매한 감정이 섞여 있습니다.";
    } else if (pieces.length === 1) {
      text = `${pieces[0]}이(가) 강한 형상입니다.`;
    } else {
      text = pieces.join(" · ") + " 이(가) 섞인 형상입니다.";
    }
  }

  ectx.fillText(text, w/2, h*0.8);
}

// 루프
function loop(ts) {
  if (!lastTime) lastTime = ts;
  const dt = ts - lastTime;
  lastTime = ts;

  drawEmotionCreature(dt);
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

</script>
</body>
</html>


