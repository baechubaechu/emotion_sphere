<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Deep Digital Sphere</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; font-family: 'Pretendard', sans-serif; user-select: none; }
    
    #container { position: absolute; width: 100%; height: 100%; top: 0; left: 0; z-index: 0; }
    
    /* 비상 탈출 버튼 (우측 상단, 투명도 낮음) */
    #emergency-btn {
      position: fixed; top: 15px; right: 15px; width: 40px; height: 40px; z-index: 9999;
      color: rgba(255, 255, 255, 0.2); font-size: 24px; display: flex; justify-content: center; align-items: center;
      cursor: pointer; border-radius: 50%; transition: all 0.3s;
    }
    #emergency-btn:active { color: #fff; background: rgba(255,255,255,0.2); }

    /* 화면 전환 공통 */
    .screen {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      transition: opacity 0.5s ease; z-index: 10; pointer-events: none;
    }
    .screen.active { opacity: 1; pointer-events: auto; }
    .screen.hidden { opacity: 0; pointer-events: none; display: none; }

    /* 버튼 스타일 */
    button.main-btn {
      padding: 16px 40px; border: 1px solid rgba(255, 255, 255, 0.4);
      background: rgba(0, 0, 0, 0.6); color: #fff; font-size: 16px; letter-spacing: 2px;
      cursor: pointer; border-radius: 50px; backdrop-filter: blur(5px); text-transform: uppercase;
    }
    button.main-btn:active { transform: scale(0.95); }

    /* 1. 시작 화면 */
    #start-screen { z-index: 30; background: #000; } 
    #startBtn { border: none; background: transparent; font-size: 22px; letter-spacing: 4px; animation: pulse 2s infinite; color: #fff; cursor: pointer; }
    @keyframes pulse { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }

    /* 2. 카메라 화면 */
    #camera-screen { justify-content: flex-end; padding-bottom: 60px; background: rgba(0,0,0,0.3); }
    #camera-frame {
      position: absolute; top: 45%; left: 50%; transform: translate(-50%, -50%);
      width: 300px; height: 300px; border: 1px solid rgba(255,255,255,0.3); background: #000; overflow: hidden;
    }
    #cam { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); opacity: 0.8; }
    #face-guide {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      width: 60%; height: 70%; border: 2px dashed rgba(255,255,255,0.5); border-radius: 50%;
    }
    
    /* 3. 결과 화면 */
    #retry-screen { justify-content: flex-end; padding-bottom: 60px; }
    #info-text { position: absolute; top: 15%; width: 100%; text-align: center; color: rgba(255,255,255,0.7); }
    
    /* 캡쳐용 캔버스 (숨김) */
    #snap { display: none; }
  </style>
</head>
<body>

<div id="emergency-btn">⟳</div>
<div id="container"></div>

<div id="start-screen" class="screen active">
  <button id="startBtn">TOUCH TO START</button>
</div>

<div id="camera-screen" class="screen hidden">
  <div id="camera-frame">
    <video id="cam" autoplay playsinline muted></video>
    <div id="face-guide"></div>
  </div>
  <button id="scanBtn" class="main-btn">SCAN AURA</button>
</div>

<div id="retry-screen" class="screen hidden">
  <div id="info-text">데이터를 공간화하고 있습니다...</div>
  <button id="retryBtn" class="main-btn">↺ RE-SCAN</button>
</div>

<canvas id="snap"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
// [서버 주소]
const SERVER_URL = "https://emotion-server-backend-907115489834.asia-northeast3.run.app/analyze";

/* ================= [0] 유틸리티 (비상탈출, 노이즈) ================= */
document.getElementById('emergency-btn').addEventListener('click', () => {
  if(confirm("시스템을 재시작하시겠습니까?")) location.reload();
});

const SimplexNoise = function() {
  this.grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],[1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],[0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]];
  this.p = []; for (var i=0; i<256; i++) this.p[i] = Math.floor(Math.random()*256);
  this.perm = []; for(var i=0; i<512; i++) this.perm[i]=this.p[i & 255];
};
SimplexNoise.prototype.dot = function(g, x, y) { return g[0]*x + g[1]*y; };
SimplexNoise.prototype.noise = function(xin, yin) {
  var n0, n1, n2; 
  var F2 = 0.5*(Math.sqrt(3.0)-1.0), G2 = (3.0-Math.sqrt(3.0))/6.0;
  var s = (xin+yin)*F2; var i = Math.floor(xin+s); var j = Math.floor(yin+s);
  var t = (i+j)*G2; var X0 = i-t; var Y0 = j-t; var x0 = xin-X0; var y0 = yin-Y0;
  var i1, j1; 
  if(x0>y0) {i1=1; j1=0;} else {i1=0; j1=1;}
  var x1 = x0 - i1 + G2; var y1 = y0 - j1 + G2;
  var x2 = x0 - 1.0 + 2.0 * G2; var y2 = y0 - 1.0 + 2.0 * G2;
  var ii = i & 255; var jj = j & 255;
  var gi0 = this.perm[ii+this.perm[jj]] % 12; var gi1 = this.perm[ii+i1+this.perm[jj+j1]] % 12; var gi2 = this.perm[ii+1+this.perm[jj+1]] % 12;
  var t0 = 0.5 - x0*x0 - y0*y0;
  if(t0<0) n0 = 0.0; else { t0 *= t0; n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0); }
  var t1 = 0.5 - x1*x1 - y1*y1;
  if(t1<0) n1 = 0.0; else { t1 *= t1; n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1); }
  var t2 = 0.5 - x2*x2 - y2*y2;
  if(t2<0) n2 = 0.0; else { t2 *= t2; n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2); }
  return 70.0 * (n0 + n1 + n2);
};
const noise = new SimplexNoise();


/* ================= [1] UI 및 카메라 로직 ================= */
const startScreen = document.getElementById("start-screen");
const cameraScreen = document.getElementById("camera-screen");
const retryScreen = document.getElementById("retry-screen");
const startBtn = document.getElementById("startBtn");
const scanBtn = document.getElementById("scanBtn");
const retryBtn = document.getElementById("retryBtn");
const infoText = document.getElementById("info-text");
const videoElement = document.getElementById("cam");

let stream = null;
let idleTimer = null;
const IDLE_LIMIT = 60000;

startBtn.addEventListener("click", async () => {
  try {
    stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "user" } });
    videoElement.srcObject = stream;
    videoElement.play();
  } catch (e) { alert("카메라 권한이 필요합니다."); return; }

  showScreen(cameraScreen);
  resetIdleTimer();
});

scanBtn.addEventListener("click", async () => {
  resetIdleTimer();
  showScreen(null);
  retryScreen.classList.remove("hidden"); retryScreen.classList.add("active");
  retryBtn.style.display = "none";
  infoText.textContent = "표정을 공간 좌표로 변환 중...";
  
  // 모든 구를 '분석 중' 상태로 (희미하게)
  spheres.forEach(s => s.setAnalyzing(true));

  const canvas = document.getElementById("snap");
  const ctx = canvas.getContext("2d");
  
  // 서버 분석 해상도(640x480)에 맞춤 -> 좌표 매핑 정확도 향상
  canvas.width = 640;
  canvas.height = 480;
  
  ctx.save();
  ctx.scale(-1, 1); // 좌우 반전 (거울모드)
  ctx.drawImage(videoElement, -canvas.width, 0, canvas.width, canvas.height);
  ctx.restore();

  // 기본 기기 정보 수집 (저장용)
  const basicMeta = { device: navigator.userAgent, timestamp: new Date().toString() };

  canvas.toBlob(async blob => {
    const form = new FormData();
    form.append("frame", blob, "frame.jpg");
    form.append("metadata", JSON.stringify(basicMeta));
    
    try {
      const res = await fetch(SERVER_URL, { method: "POST", body: form });
      if(!res.ok) throw new Error("Error");
      const data = await res.json();
      
      if (data.status === "ok" && data.face_count > 0) {
        infoText.textContent = "";
        // 얼굴 리스트를 받아 구 위치 업데이트
        updateSpheresState(data.faces_list);
      } else {
        infoText.textContent = "얼굴을 찾을 수 없습니다.";
        updateSpheresState([]); // 모두 숨김
      }
    } catch (e) { 
      console.error(e); 
      infoText.textContent = "서버 연결 실패"; 
      updateSpheresState([]);
    } 
    finally {
      // 분석 상태 해제
      spheres.forEach(s => s.setAnalyzing(false));
      setTimeout(() => { retryBtn.style.display = "block"; }, 2000);
    }
  }, "image/jpeg", 0.9);
});

retryBtn.addEventListener("click", () => {
  resetIdleTimer();
  showScreen(cameraScreen);
  // 배경 모드로 전환
  spheres.forEach(s => s.setBackground());
  videoElement.play();
});

function resetIdleTimer() {
  if (idleTimer) clearTimeout(idleTimer);
  idleTimer = setTimeout(() => { location.reload(); }, IDLE_LIMIT);
}
function showScreen(target) {
  [startScreen, cameraScreen, retryScreen].forEach(s => { s.classList.remove("active"); s.classList.add("hidden"); });
  if (target) { target.classList.remove("hidden"); target.classList.add("active"); }
}


/* ================= [2] Three.js: Multi-Sphere System ================= */
let scene, camera, renderer;
let time = 0;
const MAX_SPHERES = 6; // 최대 6명까지
let spheres = []; 

// 분석 이미지 기준 크기 (좌표 매핑용)
const IMG_W = 640;
const IMG_H = 480;

class Sphere {
    constructor(scene) {
        // 입자 수: 4000개 (다수 렌더링 성능 최적화)
        this.particleCount = 4000;
        this.radius = 70; 
        this.particlesData = [];
        this.emotions = { joy: 0, sorrow: 0, anger: 0, surprise: 0 };
        this.pose = { pan: 0, tilt: 0, boxSize: 0.5 };
        this.isActive = false;
        this.targetOpacity = 0.0;
        this.currentOpacity = 0.0;
        
        this._initMesh(scene);
    }

    _initMesh(scene) {
        const posArray = new Float32Array(this.particleCount * 3);
        const colorArray = new Float32Array(this.particleCount * 3);

        for(let i=0; i<this.particleCount; i++) {
            const phi = Math.acos( -1 + ( 2 * i ) / this.particleCount );
            const theta = Math.sqrt( this.particleCount * Math.PI ) * phi;
            const x = this.radius * Math.cos( theta ) * Math.sin( phi );
            const y = this.radius * Math.sin( theta ) * Math.sin( phi );
            const z = this.radius * Math.cos( phi );

            posArray[i*3] = x; posArray[i*3+1] = y; posArray[i*3+2] = z;
            this.particlesData.push({ ox: x, oy: y, oz: z, seed: Math.random() * 100 });
            colorArray[i*3] = 1; colorArray[i*3+1] = 1; colorArray[i*3+2] = 1;
        }
        
        const geo = new THREE.BufferGeometry();
        geo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        geo.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));
        const mat = new THREE.PointsMaterial({ 
            size: 2.5, vertexColors: true, transparent: true, opacity: 0, 
            blending: THREE.AdditiveBlending, depthWrite: false 
        });
        
        this.mesh = new THREE.Points(geo, mat);
        scene.add(this.mesh);
    }

    updateData(faceData) {
        this.emotions = faceData.emotions;
        this.pose = faceData.pose;
        this.isActive = true;
        this.targetOpacity = 1.0;
    }

    hide() {
        this.isActive = false;
        this.targetOpacity = 0.0;
        // 감정 초기화
        this.emotions = { joy: 0, sorrow: 0, anger: 0, surprise: 0 };
    }

    setAnalyzing(isAnalyzing) { if(this.isActive && isAnalyzing) this.targetOpacity = 0.4; }
    setBackground() { if(this.isActive) this.targetOpacity = 0.2; }

    animate(time) {
        // 투명도 애니메이션
        this.currentOpacity += (this.targetOpacity - this.currentOpacity) * 0.05;
        this.mesh.material.opacity = this.currentOpacity;

        // 안 보이면 연산 생략
        if (this.currentOpacity < 0.01) return;

        const positions = this.mesh.geometry.attributes.position.array;
        const colors = this.mesh.geometry.attributes.color.array;
        const { joy, sorrow, anger, surprise } = this.emotions;
        const { pan, tilt, boxSize } = this.pose;

        // 1. 고개 각도 반영 (회전)
        this.mesh.rotation.y += (pan * 0.8 - this.mesh.rotation.y) * 0.05;
        this.mesh.rotation.x += (-tilt * 0.8 - this.mesh.rotation.x) * 0.05;
        
        // 2. 얼굴 크기 반영 (Scale)
        const targetScale = 0.8 + (boxSize * 0.5);
        this.mesh.scale.setScalar(this.mesh.scale.x + (targetScale - this.mesh.scale.x) * 0.05);

        // 3. 감정 파라미터
        let tr=0.5, tg=0.5, tb=0.8; 
        let noiseIntensity = 0.5; let breathingSpeed = 1.0; let pulse = 0.0;          

        if (this.isActive) {
            if (joy > 0.1) { tr=1.0; tg=0.9; tb=0.2; noiseIntensity = 2.0; pulse = joy * 15; }
            if (anger > 0.1) { tr=1.0; tg=0.1; tb=0.1; noiseIntensity = 10.0 + anger * 10; breathingSpeed = 5.0; }
            if (sorrow > 0.1) { tr=0.1; tg=0.3; tb=0.9; noiseIntensity = 1.0; }
            if (surprise > 0.1) { tr=1.0; tg=1.0; tb=1.0; noiseIntensity = 5.0; pulse = surprise * 25; }
        }

        // 4. 입자 움직임 계산
        for (let i = 0; i < this.particleCount; i++) {
            const idx = i * 3;
            const p = this.particlesData[i];
            let x = p.ox; let y = p.oy; let z = p.oz;

            const n = noise.noise(x * 0.01 + time, y * 0.01 + time * breathingSpeed);
            const distortion = n * noiseIntensity;
            const len = Math.sqrt(x*x + y*y + z*z);
            const nx = x / len; const ny = y / len; const nz = z / len;

            let finalX = x + nx * (distortion + pulse);
            let finalY = y + ny * (distortion + pulse);
            let finalZ = z + nz * (distortion + pulse);

            // 슬픔: 아래로 처짐
            if (sorrow > 0.2) finalY -= Math.abs(n) * (sorrow * 30);

            positions[idx] = finalX; positions[idx+1] = finalY; positions[idx+2] = finalZ;

            colors[idx] += (tr - colors[idx]) * 0.05; 
            colors[idx+1] += (tg - colors[idx+1]) * 0.05; 
            colors[idx+2] += (tb - colors[idx+2]) * 0.05;
        }
        this.mesh.geometry.attributes.position.needsUpdate = true;
        this.mesh.geometry.attributes.color.needsUpdate = true;
    }
}

function initThree() {
    const container = document.getElementById("container");
    scene = new THREE.Scene(); scene.background = new THREE.Color(0x000000);
    
    // 카메라는 넓게 보기 위해 멀리 배치
    camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 2000);
    camera.position.z = 600; 

    renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);

    // 최대 개수만큼 구 생성
    for (let i = 0; i < MAX_SPHERES; i++) {
        spheres.push(new Sphere(scene));
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
}

// [핵심] 서버의 얼굴 좌표를 3D 공간 좌표로 매핑하는 함수
function updateSpheresState(facesList) {
    const count = Math.min(facesList.length, MAX_SPHERES);
    
    // 3D 화면의 실제 가시 영역 계산 (Z=0 평면 기준)
    // Three.js 카메라 거리와 FOV를 이용해 화면의 너비/높이를 구함
    const dist = camera.position.z;
    const vFOV = THREE.Math.degToRad(camera.fov); 
    const visibleHeight = 2 * Math.tan(vFOV / 2) * dist;
    const visibleWidth = visibleHeight * camera.aspect;

    for (let i = 0; i < count; i++) {
        const faceData = facesList[i];
        spheres[i].updateData(faceData);
        
        // 1. 얼굴 사각형 중심점 (0~640, 0~480)
        const rect = faceData.rect;
        const centerX = (rect.min_x + rect.max_x) / 2;
        const centerY = (rect.min_y + rect.max_y) / 2;

        // 2. 정규화 (-0.5 ~ 0.5) 및 좌표계 보정
        // X축: 좌우반전 (미러링) -> -를 붙여줌
        // Y축: 캔버스(위가0) vs 3D(중앙이0, 위가+) -> -를 붙여줌
        const normX = -((centerX / IMG_W) - 0.5);
        const normY = -((centerY / IMG_H) - 0.5);

        // 3. 3D 좌표로 변환
        const targetX = normX * visibleWidth;
        const targetY = normY * visibleHeight;

        // 위치 적용
        spheres[i].mesh.position.x = targetX;
        spheres[i].mesh.position.y = targetY;
        spheres[i].mesh.position.z = 0;
    }

    // 인식 안 된 나머지 구는 숨김
    for (let i = count; i < MAX_SPHERES; i++) {
        spheres[i].hide();
    }
}

function animate() {
    requestAnimationFrame(animate);
    time += 0.005;
    spheres.forEach(s => s.animate(time));
    renderer.render(scene, camera);
}

initThree(); 
animate();
</script>
</body>
</html>
