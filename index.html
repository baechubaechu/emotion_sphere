<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Digital Aura Exhibition</title>
  <style>
    /* 기본 설정 */
    body { margin: 0; overflow: hidden; background: #000; font-family: 'Pretendard', sans-serif; user-select: none; }
    
    /* Three.js 배경 (가장 뒤) */
    #container { position: absolute; width: 100%; height: 100%; top: 0; left: 0; z-index: 0; }
    
    /* 공통 UI 스타일 */
    .screen {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      transition: opacity 0.5s ease;
      z-index: 10;
      pointer-events: none; /* 배경 터치 통과 */
    }
    .screen.hidden { opacity: 0; pointer-events: none; display: none; } /* display: none 추가 */
    .screen.active { opacity: 1; pointer-events: auto; display: flex; }

    /* 버튼 스타일 */
    button {
      padding: 15px 40px;
      border: 1px solid rgba(255, 255, 255, 0.4);
      background: rgba(0, 0, 0, 0.5);
      color: #fff; font-size: 16px; letter-spacing: 2px;
      cursor: pointer; border-radius: 4px;
      backdrop-filter: blur(5px);
      transition: all 0.3s;
      pointer-events: auto;
      text-transform: uppercase;
    }
    button:hover { background: rgba(255, 255, 255, 0.2); border-color: #fff; }
    button:active { transform: scale(0.95); }


    /* 1. 대기 화면 (Start Screen) */
    #start-screen { z-index: 30; background: #000; } 
    #startBtn {
      border: none; background: transparent;
      font-size: 24px; letter-spacing: 5px;
      animation: pulse 2s infinite;
    }
    @keyframes pulse { 0% { opacity: 0.4; } 50% { opacity: 1; } 100% { opacity: 0.4; } }


    /* 2. 카메라 화면 (Camera Screen) */
    #camera-screen {
      justify-content: flex-end; padding-bottom: 60px;
      background: rgba(0,0,0,0.3); /* 배경 살짝 어둡게 */
    }

    #camera-frame {
      position: absolute; top: 50%; left: 50%;
      transform: translate(-50%, -60%);
      width: 300px; height: 300px; /* 네모난 모양 */
      border: 1px solid rgba(255, 255, 255, 0.3);
      background: #000;
      overflow: hidden;
      box-shadow: 0 0 50px rgba(0,0,0,0.5);
    }

    #cam {
      width: 100%; height: 100%;
      object-fit: cover;
      transform: scaleX(-1); /* 거울모드 */
      opacity: 0.9;
    }

    /* 얼굴 가이드 (네모 안의 타원) */
    #face-guide {
      position: absolute; top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      width: 60%; height: 70%;
      border: 2px dashed rgba(255, 255, 255, 0.5);
      border-radius: 50%;
      box-shadow: 0 0 0 100vmax rgba(0,0,0,0.5); 
    }

    #scanBtn {
      margin-top: 20px; font-weight: bold; background: #fff; color: #000; border: none;
      z-index: 50; /* 버튼이 확실히 위에 오도록 */
    }


    /* 3. 결과/다시하기 화면 (Retry Screen) */
    #retry-screen {
      justify-content: flex-end; padding-bottom: 60px;
    }
    #info-text {
      position: absolute; top: 15%; width: 100%;
      text-align: center; color: rgba(255,255,255,0.7);
      font-size: 16px; letter-spacing: 1px;
    }

    #snap { display: none; }
  </style>
</head>
<body>

<div id="container"></div>

<div id="start-screen" class="screen active">
  <button id="startBtn">TOUCH TO START</button>
</div>

<div id="camera-screen" class="screen hidden">
  <div id="camera-frame">
    <video id="cam" autoplay playsinline muted></video>
    <div id="face-guide"></div>
  </div>
  <button id="scanBtn">SCAN</button>
</div>

<div id="retry-screen" class="screen hidden">
  <div id="info-text">데이터를 해석하고 있습니다...</div>
  <button id="retryBtn">↺ RE-SCAN</button>
</div>

<canvas id="snap" width="640" height="480"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/josephg/noisejs/perlin.js"></script>

<script>
// [서버 주소]
const SERVER_URL = "https://emotion-server-backend-907115489834.asia-northeast3.run.app/analyze";

/* ================= [1] 상태 관리 및 시퀀스 로직 ================= */
const startScreen = document.getElementById("start-screen");
const cameraScreen = document.getElementById("camera-screen");
const retryScreen = document.getElementById("retry-screen");

const startBtn = document.getElementById("startBtn");
const scanBtn = document.getElementById("scanBtn");
const retryBtn = document.getElementById("retryBtn");
const infoText = document.getElementById("info-text");

const videoElement = document.getElementById("cam");
let stream = null;
let idleTimer = null;
const IDLE_LIMIT = 60000; // 1분

// 1. 접속하자마자 카메라 권한 요청
async function initCamera() {
  try {
    console.log("Requesting Camera...");
    stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: "user", width: 640, height: 480 }
    });
    videoElement.srcObject = stream;
    await videoElement.play();
    console.log("Camera started in background.");
  } catch (e) {
    console.warn("Autoplay blocked or permission denied. Waiting for user gesture.", e);
  }
}

window.addEventListener("load", initCamera);

// 2. [TOUCH TO START]
startBtn.addEventListener("click", async () => {
  if (!stream) {
    await initCamera();
  }
  showScreen(cameraScreen);
  resetIdleTimer();
});

// 3. [SCAN]
scanBtn.addEventListener("click", async () => {
  console.log("Scan button clicked");

  if (!stream) {
    await initCamera();
    if (!stream) {
      alert("카메라 오류. 새로고침 해주세요.");
      return;
    }
  }

  resetIdleTimer();

  // UI 전환
  showScreen(null);
  retryScreen.classList.remove("hidden");
  retryScreen.classList.add("active");
  retryBtn.style.display = "none";
  infoText.textContent = "에너지를 해석하고 있습니다...";

  setAnalyzingState(true);

  const canvas = document.getElementById("snap");
  const ctx = canvas.getContext("2d");

  if (videoElement.videoWidth > 0) {
    canvas.width = videoElement.videoWidth;
    canvas.height = videoElement.videoHeight;
  }

  // 좌우반전 캡처
  ctx.save();
  ctx.scale(-1, 1);
  ctx.drawImage(videoElement, -canvas.width, 0, canvas.width, canvas.height);
  ctx.restore();

  canvas.toBlob(async blob => {
    const form = new FormData();
    form.append("frame", blob, "frame.jpg");

    try {
      console.log("Sending to server...");
      const res = await fetch(SERVER_URL, { method: "POST", body: form });
      if (!res.ok) throw new Error("Server Error");
      const data = await res.json();
      console.log("Data received:", data);

      if (data.status === "ok") {
        infoText.textContent = "";
        updateEmotionViz(data); // 감정 시각화 업데이트
      } else {
        infoText.textContent = "인식된 얼굴이 없습니다.";
        resetEmotion(false);
      }
    } catch (e) {
      console.error(e);
      infoText.textContent = "서버 연결 실패";
      resetEmotion(false);
    } finally {
      setAnalyzingState(false);
      setTimeout(() => {
        retryBtn.style.display = "block";
      }, 2000);
    }
  }, "image/jpeg", 0.9);
});

// 4. [RE-SCAN]
retryBtn.addEventListener("click", () => {
  resetIdleTimer();
  showScreen(cameraScreen);
  setBackgroundState();
  if (videoElement.paused) videoElement.play();
});

// 5. 자동 초기화
function resetIdleTimer() {
  if (idleTimer) clearTimeout(idleTimer);
  idleTimer = setTimeout(() => {
    console.log("Timeout -> Reset to Start Screen");
    showScreen(startScreen);
    resetEmotion(true);
    stopIdleTimer();
  }, IDLE_LIMIT);
}
function stopIdleTimer() {
  if (idleTimer) clearTimeout(idleTimer);
  idleTimer = null;
}

function showScreen(target) {
  [startScreen, cameraScreen, retryScreen].forEach(s => {
    s.classList.remove("active");
    s.classList.add("hidden");
  });
  if (target) {
    target.classList.remove("hidden");
    target.classList.add("active");
  }
}

// 인터랙션 감지
window.addEventListener("touchstart", () => {
  if (!startScreen.classList.contains("active")) resetIdleTimer();
});
window.addEventListener("click", () => {
  if (!startScreen.classList.contains("active")) resetIdleTimer();
});


/* ================= [2] 감정 나침반 Canvas 시각화 ================= */

// #container 안에 풀스크린 캔버스 하나 추가
const container = document.getElementById("container");
const emotionCanvas = document.createElement("canvas");
emotionCanvas.id = "emotionCanvas";
emotionCanvas.style.position = "absolute";
emotionCanvas.style.top = "0";
emotionCanvas.style.left = "0";
emotionCanvas.style.width = "100%";
emotionCanvas.style.height = "100%";
emotionCanvas.style.pointerEvents = "none"; // 터치 방해하지 않게
container.appendChild(emotionCanvas);

const ectx = emotionCanvas.getContext("2d");
let canvasWidth = 0;
let canvasHeight = 0;

// hiDPI 대응
function resizeEmotionCanvas() {
  const dpr = window.devicePixelRatio || 1;
  const rect = container.getBoundingClientRect();
  canvasWidth = rect.width;
  canvasHeight = rect.height;
  emotionCanvas.width = rect.width * dpr;
  emotionCanvas.height = rect.height * dpr;
  ectx.setTransform(dpr, 0, 0, dpr, 0, 0);
}

window.addEventListener("resize", resizeEmotionCanvas);
resizeEmotionCanvas();

// 감정 상태
let currentEmotion = {
  joy: 0,
  sorrow: 0,
  anger: 0,
  surprise: 0,
  intensity: 0,
  labelMain: "",
  labelSub: ""
};

let targetEmotion = { ...currentEmotion };
let analyzing = false;
let lastTime = 0;

function lerp(a, b, t) {
  return a + (b - a) * t;
}

// 구글 비전에서 온 감정값 정리 & 필터링
function processEmotions(raw) {
  let joy = raw.joy ?? 0;
  let sorrow = raw.sorrow ?? 0;
  let anger = raw.anger ?? 0;
  let surprise = raw.surprise ?? 0;

  // 혹시 0~3 같은 값이면 스케일링
  const maxRaw = Math.max(joy, sorrow, anger, surprise, 1);
  if (maxRaw > 1.0) {
    joy /= maxRaw;
    sorrow /= maxRaw;
    anger /= maxRaw;
    surprise /= maxRaw;
  }

  // 가장 큰 값 기준으로 너무 작은 감정은 아예 버려서
  // "joy 1.0 surprise 1.0" 같은 극단적 동시값만 남기고
  // 애매한 노이즈는 삭제
  const arr = [
    { key: "joy", kor: "기쁨", value: joy },
    { key: "sorrow", kor: "슬픔", value: sorrow },
    { key: "anger", kor: "분노", value: anger },
    { key: "surprise", kor: "놀람", value: surprise }
  ];
  arr.sort((a, b) => b.value - a.value);
  const maxVal = arr[0].value;

  // max 기준 40% 미만은 0으로 잘라냄 (노이즈 제거)
  const cutoff = maxVal * 0.4;
  for (const obj of arr) {
    if (obj.value < cutoff) obj.value = 0;
  }

  // 다시 변수로
  joy = arr.find(e => e.key === "joy").value;
  sorrow = arr.find(e => e.key === "sorrow").value;
  anger = arr.find(e => e.key === "anger").value;
  surprise = arr.find(e => e.key === "surprise").value;

  const sum = joy + sorrow + anger + surprise;
  let wJoy = 0, wSor = 0, wAng = 0, wSur = 0;
  if (sum > 0) {
    wJoy = joy / sum;
    wSor = sorrow / sum;
    wAng = anger / sum;
    wSur = surprise / sum;
  }

  // 라벨용 텍스트 생성
  let labelMain = "감정을 해석할 수 없습니다";
  let labelSub = "";

  if (maxVal < 0.2) {
    labelMain = "감정이 거의 감지되지 않았습니다";
  } else {
    const active = arr.filter(e => e.value > 0);
    if (active.length === 1) {
      const p = Math.round((active[0].value / (sum || 1)) * 100);
      labelMain = `${active[0].kor}이(가) 우세한 표정`;
      labelSub = `AI 추정 강도: 약 ${p}%`;
    } else if (active.length >= 2) {
      const a = active[0];
      const b = active[1];
      const p1 = Math.round((a.value / (sum || 1)) * 100);
      const p2 = Math.round((b.value / (sum || 1)) * 100);
      labelMain = `${a.kor}과(와) ${b.kor}이(가 섞인 표정`;
      labelSub = `${a.kor} 약 ${p1}%, ${b.kor} 약 ${p2}%`;
    }
  }

  return {
    joy: wJoy,
    sorrow: wSor,
    anger: wAng,
    surprise: wSur,
    intensity: maxVal, // 가장 강한 감정의 세기
    labelMain,
    labelSub
  };
}

// 서버에서 받은 감정값 → 타겟 상태 업데이트
function updateEmotionViz(data) {
  if (!data.emotions) return;
  targetEmotion = processEmotions(data.emotions);

  // 감정이 강할수록 더 또렷하게 보이도록
}

// 분석 중 상태
function setAnalyzingState(isAnalyzing) {
  analyzing = isAnalyzing;
}

// 카메라 화면에서 뒤에 깔리는 잔잔한 상태
function setBackgroundState() {
  // 감정은 유지하되 강도만 살짝 줄임
  targetEmotion.intensity *= 0.5;
}

// 리셋
function resetEmotion(fully) {
  if (fully) {
    targetEmotion = {
      joy: 0,
      sorrow: 0,
      anger: 0,
      surprise: 0,
      intensity: 0,
      labelMain: "",
      labelSub: ""
    };
  } else {
    targetEmotion.intensity *= 0.3;
  }
}

// 메인 그리기 루프
function drawEmotionCompass(delta) {
  const t = Math.min(delta * 0.005, 0.2); // 보간 속도

  // 현재 상태를 타겟에 맞춰 부드럽게 보간
  currentEmotion.joy = lerp(currentEmotion.joy, targetEmotion.joy, t);
  currentEmotion.sorrow = lerp(currentEmotion.sorrow, targetEmotion.sorrow, t);
  currentEmotion.anger = lerp(currentEmotion.anger, targetEmotion.anger, t);
  currentEmotion.surprise = lerp(currentEmotion.surprise, targetEmotion.surprise, t);
  currentEmotion.intensity = lerp(currentEmotion.intensity, targetEmotion.intensity, t);
  currentEmotion.labelMain = targetEmotion.labelMain;
  currentEmotion.labelSub = targetEmotion.labelSub;

  const w = canvasWidth;
  const h = canvasHeight;
  if (w === 0 || h === 0) return;

  // 배경 살짝 어둡게
  ectx.clearRect(0, 0, w, h);
  ectx.fillStyle = "rgba(0,0,0,0.8)";
  ectx.fillRect(0, 0, w, h);

  const cx = w / 2;
  const cy = h * 0.45;
  const baseRadius = Math.min(w, h) * 0.07;
  const extraRadius = Math.min(w, h) * 0.12 * (0.3 + currentEmotion.intensity);

  // 전체 "호흡" 애니메이션
  const time = performance.now() * 0.001;
  const breath = Math.sin(time * 1.0) * 0.05;

  // 분석 중일 때는 살짝 회전
  const baseRotation = analyzing ? time * 1.2 : 0;

  // 각 감정 방향(라디안)
  const angles = {
    joy: -Math.PI / 2,
    anger: 0,
    sorrow: Math.PI / 2,
    surprise: Math.PI
  };

  // 각 감정별 색
  const colors = {
    joy: "#ffd86b",
    sorrow: "#6fa8ff",
    anger: "#ff5a5a",
    surprise: "#ffffff"
  };

  // 각 감정 끝점 위치 계산
  const ends = {};

  ["joy", "anger", "sorrow", "surprise"].forEach(key => {
    const ang = angles[key] + baseRotation;
    const wVal = currentEmotion[key];
    const r = baseRadius + extraRadius * wVal * (1 + breath);
    const ex = cx + Math.cos(ang) * r;
    const ey = cy + Math.sin(ang) * r;

    ends[key] = { x: ex, y: ey, weight: wVal };
  });

  // 중심에 옅은 원 (전체 감정의 "용기")
  const auraR = baseRadius + extraRadius * currentEmotion.intensity * 0.4;
  const grd = ectx.createRadialGradient(cx, cy, auraR * 0.1, cx, cy, auraR);
  grd.addColorStop(0, "rgba(255,255,255,0.25)");
  grd.addColorStop(1, "rgba(255,255,255,0.0)");
  ectx.fillStyle = grd;
  ectx.beginPath();
  ectx.arc(cx, cy, auraR, 0, Math.PI * 2);
  ectx.fill();

  // 감정 "꽃잎" (각 감정 방향으로 뻗은 형태)
  ["joy", "anger", "sorrow", "surprise"].forEach(key => {
    const end = ends[key];
    if (end.weight <= 0.001) return; // 감정이 거의 없으면 그리지 않음

    const ang = angles[key] + baseRotation;
    const midAng1 = ang - 0.25;
    const midAng2 = ang + 0.25;
    const rInner = baseRadius * 0.4;
    const rOuter = baseRadius + extraRadius * end.weight;

    const x1 = cx + Math.cos(midAng1) * rInner;
    const y1 = cy + Math.sin(midAng1) * rInner;
    const x2 = cx + Math.cos(midAng1) * rOuter;
    const y2 = cy + Math.sin(midAng1) * rOuter;
    const x3 = cx + Math.cos(midAng2) * rOuter;
    const y3 = cy + Math.sin(midAng2) * rOuter;
    const x4 = cx + Math.cos(midAng2) * rInner;
    const y4 = cy + Math.sin(midAng2) * rInner;

    ectx.beginPath();
    ectx.moveTo(x1, y1);
    ectx.quadraticCurveTo(cx, cy, x2, y2);
    ectx.lineTo(x3, y3);
    ectx.quadraticCurveTo(cx, cy, x4, y4);
    ectx.closePath();

    const alpha = 0.3 + end.weight * 0.6;
    ectx.fillStyle = hexToRgba(colors[key], alpha);
    ectx.fill();
  });

  // 중심 원
  ectx.beginPath();
  ectx.arc(cx, cy, baseRadius * 0.4, 0, Math.PI * 2);
  ectx.fillStyle = "rgba(0,0,0,0.8)";
  ectx.fill();
  ectx.lineWidth = 1;
  ectx.strokeStyle = "rgba(255,255,255,0.4)";
  ectx.stroke();

  // 중심 십자선
  ectx.strokeStyle = "rgba(255,255,255,0.1)";
  ectx.beginPath();
  ectx.moveTo(cx - baseRadius * 1.1, cy);
  ectx.lineTo(cx + baseRadius * 1.1, cy);
  ectx.stroke();
  ectx.beginPath();
  ectx.moveTo(cx, cy - baseRadius * 1.1);
  ectx.lineTo(cx, cy + baseRadius * 1.1);
  ectx.stroke();

  // 각 감정 라벨 (네 귀퉁이)
  ectx.font = "12px Pretendard, system-ui, sans-serif";
  ectx.textAlign = "center";
  ectx.textBaseline = "middle";

  drawEmotionLabel(cx, cy - auraR * 1.2, "기쁨", currentEmotion.joy, colors.joy);
  drawEmotionLabel(cx + auraR * 1.4, cy, "분노", currentEmotion.anger, colors.anger);
  drawEmotionLabel(cx, cy + auraR * 1.2, "슬픔", currentEmotion.sorrow, colors.sorrow);
  drawEmotionLabel(cx - auraR * 1.4, cy, "놀람", currentEmotion.surprise, colors.surprise);

  // 하단 텍스트 박스
  drawBottomTextBox();
}

function drawEmotionLabel(x, y, text, weight, color) {
  const alpha = 0.25 + weight * 0.6;
  ectx.fillStyle = hexToRgba(color, alpha);
  ectx.beginPath();
  ectx.arc(x, y, 8 + weight * 12, 0, Math.PI * 2);
  ectx.fill();

  ectx.fillStyle = "rgba(255,255,255,0.85)";
  ectx.font = "11px Pretendard, system-ui, sans-serif";
  ectx.textAlign = "center";
  ectx.textBaseline = "middle";
  ectx.fillText(text, x, y - 16);
}

function drawBottomTextBox() {
  const w = canvasWidth;
  const h = canvasHeight;
  const boxWidth = Math.min(420, w * 0.8);
  const boxHeight = 70;
  const x = (w - boxWidth) / 2;
  const y = h * 0.75;

  // 바탕
  ectx.fillStyle = "rgba(0,0,0,0.65)";
  ectx.beginPath();
  const r = 12;
  roundedRect(ectx, x, y, boxWidth, boxHeight, r);
  ectx.fill();

  // 테두리
  ectx.strokeStyle = "rgba(255,255,255,0.25)";
  ectx.lineWidth = 1;
  ectx.stroke();

  // 텍스트
  ectx.fillStyle = "rgba(255,255,255,0.9)";
  ectx.textAlign = "center";
  ectx.textBaseline = "middle";

  ectx.font = "14px Pretendard, system-ui, sans-serif";
  const main = currentEmotion.labelMain || "아직 감정을 읽는 중입니다";
  ectx.fillText(main, x + boxWidth / 2, y + boxHeight / 2 - 10);

  ectx.font = "11px Pretendard, system-ui, sans-serif";
  const sub = currentEmotion.labelSub || "카메라를 응시하고 자연스러운 표정을 지어보세요.";
  ectx.fillStyle = "rgba(255,255,255,0.7)";
  ectx.fillText(sub, x + boxWidth / 2, y + boxHeight / 2 + 14);
}

function roundedRect(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
}

function hexToRgba(hex, alpha) {
  const c = hex.replace("#", "");
  const num = parseInt(c, 16);
  const r = (num >> 16) & 255;
  const g = (num >> 8) & 255;
  const b = num & 255;
  return `rgba(${r},${g},${b},${alpha})`;
}

// 애니메이션 루프 시작
function emotionLoop(timestamp) {
  if (!lastTime) lastTime = timestamp;
  const delta = timestamp - lastTime;
  lastTime = timestamp;

  drawEmotionCompass(delta);
  requestAnimationFrame(emotionLoop);
}
requestAnimationFrame(emotionLoop);
</script>
</body>
</html>

