<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Digital Aura Exhibition</title>
  <style>
    /* 기본 설정 */
    body { margin: 0; overflow: hidden; background: #000; font-family: 'Pretendard', sans-serif; user-select: none; }
    
    /* Three.js 배경 (가장 뒤) */
    #container { position: absolute; width: 100%; height: 100%; top: 0; left: 0; z-index: 0; }
    
    /* 공통 UI 스타일 */
    .screen {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      transition: opacity 0.5s ease;
      z-index: 10;
      pointer-events: none; /* 배경 터치 통과 */
    }
    .screen.hidden { opacity: 0; pointer-events: none; display: none; } /* display: none 추가 */
    .screen.active { opacity: 1; pointer-events: auto; display: flex; }

    /* 버튼 스타일 */
    button {
      padding: 15px 40px;
      border: 1px solid rgba(255, 255, 255, 0.4);
      background: rgba(0, 0, 0, 0.5);
      color: #fff; font-size: 16px; letter-spacing: 2px;
      cursor: pointer; border-radius: 4px;
      backdrop-filter: blur(5px);
      transition: all 0.3s;
      pointer-events: auto;
      text-transform: uppercase;
    }
    button:hover { background: rgba(255, 255, 255, 0.2); border-color: #fff; }
    button:active { transform: scale(0.95); }


    /* 1. 대기 화면 (Start Screen) */
    #start-screen { z-index: 30; background: #000; } 
    #startBtn {
      border: none; background: transparent;
      font-size: 24px; letter-spacing: 5px;
      animation: pulse 2s infinite;
    }
    @keyframes pulse { 0% { opacity: 0.4; } 50% { opacity: 1; } 100% { opacity: 0.4; } }


    /* 2. 카메라 화면 (Camera Screen) */
    #camera-screen {
      justify-content: flex-end; padding-bottom: 60px;
      background: rgba(0,0,0,0.3); /* 배경 살짝 어둡게 */
    }

    #camera-frame {
      position: absolute; top: 50%; left: 50%;
      transform: translate(-50%, -60%);
      width: 300px; height: 300px; /* 네모난 모양 */
      border: 1px solid rgba(255, 255, 255, 0.3);
      background: #000;
      overflow: hidden;
      box-shadow: 0 0 50px rgba(0,0,0,0.5);
    }

    #cam {
      width: 100%; height: 100%;
      object-fit: cover;
      transform: scaleX(-1); /* 거울모드 */
      opacity: 0.9;
    }

    /* 얼굴 가이드 (네모 안의 타원) */
    #face-guide {
      position: absolute; top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      width: 60%; height: 70%;
      border: 2px dashed rgba(255, 255, 255, 0.5);
      border-radius: 50%;
      box-shadow: 0 0 0 100vmax rgba(0,0,0,0.5); 
    }

    #scanBtn {
      margin-top: 20px; font-weight: bold; background: #fff; color: #000; border: none;
      z-index: 50; /* 버튼이 확실히 위에 오도록 */
    }


    /* 3. 결과/다시하기 화면 (Retry Screen) */
    #retry-screen {
      justify-content: flex-end; padding-bottom: 60px;
    }
    #info-text {
      position: absolute; top: 15%; width: 100%;
      text-align: center; color: rgba(255,255,255,0.7);
      font-size: 16px; letter-spacing: 1px;
    }

    #snap { display: none; }
  </style>
</head>
<body>

<div id="container"></div>

<div id="start-screen" class="screen active">
  <button id="startBtn">TOUCH TO START</button>
</div>

<div id="camera-screen" class="screen hidden">
  <div id="camera-frame">
    <video id="cam" autoplay playsinline muted></video>
    <div id="face-guide"></div>
  </div>
  <button id="scanBtn">SCAN</button>
</div>

<div id="retry-screen" class="screen hidden">
  <div id="info-text">데이터를 해석하고 있습니다...</div>
  <button id="retryBtn">↺ RE-SCAN</button>
</div>

<canvas id="snap" width="640" height="480"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/josephg/noisejs/perlin.js"></script>

<script>
// [서버 주소]
const SERVER_URL = "https://emotion-server-backend-907115489834.asia-northeast3.run.app/analyze";

/* ================= [1] 상태 관리 및 시퀀스 로직 ================= */
const startScreen = document.getElementById("start-screen");
const cameraScreen = document.getElementById("camera-screen");
const retryScreen = document.getElementById("retry-screen");

const startBtn = document.getElementById("startBtn");
const scanBtn = document.getElementById("scanBtn");
const retryBtn = document.getElementById("retryBtn");
const infoText = document.getElementById("info-text");

const videoElement = document.getElementById("cam");
let stream = null;
let idleTimer = null;
const IDLE_LIMIT = 60000; // 1분

// 1. 접속하자마자 카메라 권한 요청
async function initCamera() {
  try {
    console.log("Requesting Camera...");
    stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: "user", width: 640, height: 480 }
    });
    videoElement.srcObject = stream;
    await videoElement.play();
    console.log("Camera started in background.");
  } catch (e) {
    console.warn("Autoplay blocked or permission denied. Waiting for user gesture.", e);
  }
}

window.addEventListener("load", initCamera);

// 2. [TOUCH TO START]
startBtn.addEventListener("click", async () => {
  if (!stream) {
    await initCamera();
  }
  showScreen(cameraScreen);
  resetIdleTimer();
});

// 3. [SCAN]
scanBtn.addEventListener("click", async () => {
  console.log("Scan button clicked");

  if (!stream) {
    await initCamera();
    if (!stream) {
      alert("카메라 오류. 새로고침 해주세요.");
      return;
    }
  }

  resetIdleTimer();

  // UI 전환
  showScreen(null);
  retryScreen.classList.remove("hidden");
  retryScreen.classList.add("active");
  retryBtn.style.display = "none";
  infoText.textContent = "데이터를 해석하고 있습니다...";

  setAnalyzingState(true);

  const canvas = document.getElementById("snap");
  const ctx = canvas.getContext("2d");

  if (videoElement.videoWidth > 0) {
    canvas.width = videoElement.videoWidth;
    canvas.height = videoElement.videoHeight;
  }

  // 좌우반전 캡처
  ctx.save();
  ctx.scale(-1, 1);
  ctx.drawImage(videoElement, -canvas.width, 0, canvas.width, canvas.height);
  ctx.restore();

  canvas.toBlob(async blob => {
    const form = new FormData();
    form.append("frame", blob, "frame.jpg");

    try {
      console.log("Sending to server...");
      const res = await fetch(SERVER_URL, { method: "POST", body: form });
      if (!res.ok) throw new Error("Server Error");
      const data = await res.json();
      console.log("Data received:", data);

      if (data.status === "ok") {
        infoText.textContent = "";
        updateAbstractShape(data); // 감정 → 형상 파라미터 업데이트
      } else {
        infoText.textContent = "인식된 얼굴이 없습니다.";
        resetEmotion(false);
      }
    } catch (e) {
      console.error(e);
      infoText.textContent = "서버 연결 실패";
      resetEmotion(false);
    } finally {
      setAnalyzingState(false);
      setTimeout(() => {
        retryBtn.style.display = "block";
      }, 2000);
    }
  }, "image/jpeg", 0.9);
});

// 4. [RE-SCAN]
retryBtn.addEventListener("click", () => {
  resetIdleTimer();
  showScreen(cameraScreen);
  setBackgroundState();
  if (videoElement.paused) videoElement.play();
});

// 5. 자동 초기화
function resetIdleTimer() {
  if (idleTimer) clearTimeout(idleTimer);
  idleTimer = setTimeout(() => {
    console.log("Timeout -> Reset to Start Screen");
    showScreen(startScreen);
    resetEmotion(true);
    stopIdleTimer();
  }, IDLE_LIMIT);
}
function stopIdleTimer() {
  if (idleTimer) clearTimeout(idleTimer);
  idleTimer = null;
}

function showScreen(target) {
  [startScreen, cameraScreen, retryScreen].forEach(s => {
    s.classList.remove("active");
    s.classList.add("hidden");
  });
  if (target) {
    target.classList.remove("hidden");
    target.classList.add("active");
  }
}

// 인터랙션 감지
window.addEventListener("touchstart", () => {
  if (!startScreen.classList.contains("active")) resetIdleTimer();
});
window.addEventListener("click", () => {
  if (!startScreen.classList.contains("active")) resetIdleTimer();
});


/* ================= [2] 감정 → 컬러 잉크 추상 형상 ================= */

// #container 안에 풀스크린 캔버스 하나 추가
const container = document.getElementById("container");
const emotionCanvas = document.createElement("canvas");
emotionCanvas.id = "emotionCanvas";
emotionCanvas.style.position = "absolute";
emotionCanvas.style.top = "0";
emotionCanvas.style.left = "0";
emotionCanvas.style.width = "100%";
emotionCanvas.style.height = "100%";
emotionCanvas.style.pointerEvents = "none";
container.appendChild(emotionCanvas);

const ectx = emotionCanvas.getContext("2d");
let cw = 0;
let ch = 0;

// hiDPI 대응
function resizeEmotionCanvas() {
  const dpr = window.devicePixelRatio || 1;
  const rect = container.getBoundingClientRect();
  cw = rect.width;
  ch = rect.height;
  emotionCanvas.width = rect.width * dpr;
  emotionCanvas.height = rect.height * dpr;
  ectx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
window.addEventListener("resize", resizeEmotionCanvas);
resizeEmotionCanvas();

// 감정 상태 (내부 파라미터)
let currentEmotion = {
  joy: 0,
  sorrow: 0,
  anger: 0,
  surprise: 0,
  valence: 0,      // joy - sorrow
  energy: 0,       // max intensity
  tension: 0,      // anger
  instability: 0   // surprise
};

let targetEmotion = { ...currentEmotion };
let analyzing = false;
let lastTime = 0;

// 랜덤 시드
let baseSeed = Math.random() * 1000;

function lerp(a, b, t) { return a + (b - a) * t; }

// HSL → RGBA 헬퍼
function hslToRgba(h, s, l, a) {
  h = ((h % 360) + 360) % 360;
  s /= 100;
  l /= 100;
  let c = (1 - Math.abs(2*l - 1)) * s;
  let x = c * (1 - Math.abs((h/60) % 2 - 1));
  let m = l - c/2;
  let r=0, g=0, b=0;
  if (0 <= h && h < 60) { r=c; g=x; b=0; }
  else if (60 <= h && h < 120) { r=x; g=c; b=0; }
  else if (120 <= h && h < 180) { r=0; g=c; b=x; }
  else if (180 <= h && h < 240) { r=0; g=x; b=c; }
  else if (240 <= h && h < 300) { r=x; g=0; b=c; }
  else { r=c; g=0; b=x; }
  r = Math.round((r+m)*255);
  g = Math.round((g+m)*255);
  b = Math.round((b+m)*255);
  return `rgba(${r},${g},${b},${a})`;
}

// 노이즈 (perlin.js)
function n2(x, y, t) {
  return noise.simplex3(x, y, t);
}

// 원시 감정값 → 조합된 지표
function processEmotions(raw) {
  let joy = raw.joy ?? 0;
  let sorrow = raw.sorrow ?? 0;
  let anger = raw.anger ?? 0;
  let surprise = raw.surprise ?? 0;

  // 0~3 같은 스케일일 경우 0~1로
  const maxRaw = Math.max(joy, sorrow, anger, surprise, 1);
  if (maxRaw > 1.0) {
    joy /= maxRaw;
    sorrow /= maxRaw;
    anger /= maxRaw;
    surprise /= maxRaw;
  }

  // 아주 작은 값 컷
  const noiseCut = 0.1;
  if (joy < noiseCut) joy = 0;
  if (sorrow < noiseCut) sorrow = 0;
  if (anger < noiseCut) anger = 0;
  if (surprise < noiseCut) surprise = 0;

  // 다시 normalize
  const sum = joy + sorrow + anger + surprise;
  if (sum > 0) {
    joy /= sum;
    sorrow /= sum;
    anger /= sum;
    surprise /= sum;
  }

  const energy      = sum > 0 ? Math.max(joy, sorrow, anger, surprise) : 0;
  const valence     = joy - sorrow;   // -1~1
  const tension     = anger;
  const instability = surprise;

  return { joy, sorrow, anger, surprise, valence, energy, tension, instability };
}

// 서버에서 온 감정 → 추상 형상 파라미터 업데이트
function updateAbstractShape(data) {
  if (!data.emotions) return;
  targetEmotion = processEmotions(data.emotions);

  if (targetEmotion.energy < 0.15) {
    targetEmotion.energy = 0.0;
  }

  baseSeed = Math.random() * 1000;
}

// 분석 중
function setAnalyzingState(isAnalyzing) {
  analyzing = isAnalyzing;
}

// 카메라 화면으로 돌아갈 때 잔상 약하게
function setBackgroundState() {
  targetEmotion.energy *= 0.4;
}

// 리셋
function resetEmotion(fully) {
  if (fully) {
    targetEmotion = {
      joy: 0,
      sorrow: 0,
      anger: 0,
      surprise: 0,
      valence: 0,
      energy: 0,
      tension: 0,
      instability: 0
    };
  } else {
    targetEmotion.energy *= 0.2;
  }
}

// 메인 그리기
function drawAbstractInk(dt) {
  const tLerp = Math.min(dt * 0.004, 0.25);

  // 감정 상태 보간
  currentEmotion.joy        = lerp(currentEmotion.joy,        targetEmotion.joy,        tLerp);
  currentEmotion.sorrow     = lerp(currentEmotion.sorrow,     targetEmotion.sorrow,     tLerp);
  currentEmotion.anger      = lerp(currentEmotion.anger,      targetEmotion.anger,      tLerp);
  currentEmotion.surprise   = lerp(currentEmotion.surprise,   targetEmotion.surprise,   tLerp);
  currentEmotion.valence    = lerp(currentEmotion.valence,    targetEmotion.valence,    tLerp);
  currentEmotion.energy     = lerp(currentEmotion.energy,     targetEmotion.energy,     tLerp);
  currentEmotion.tension    = lerp(currentEmotion.tension,    targetEmotion.tension,    tLerp);
  currentEmotion.instability= lerp(currentEmotion.instability,targetEmotion.instability,tLerp);

  const w = cw;
  const h = ch;
  if (!w || !h) return;

  const time = performance.now() * 0.001;

  // 배경 (딥 블랙, 중앙 살짝 밝음)
  ectx.clearRect(0, 0, w, h);
  const bgGrad = ectx.createRadialGradient(
    w/2, h*0.4, 0,
    w/2, h*0.4, Math.max(w,h)*0.9
  );
  bgGrad.addColorStop(0, "rgba(0,0,0,0.5)");
  bgGrad.addColorStop(1, "rgba(0,0,0,1)");
  ectx.fillStyle = bgGrad;
  ectx.fillRect(0,0,w,h);

  const cx = w / 2;
  const cy = h * 0.4;

  // 감정 기반 파라미터
  const E  = currentEmotion.energy;      // 전체 강도
  const V  = currentEmotion.valence;     // -1~1 비대칭
  const Tn = currentEmotion.tension;     // 뾰족
  const In = currentEmotion.instability; // 요동

  const baseR = Math.min(w,h) * (0.12 + 0.18*E);
  const lobesBase = 4;
  const lobes = lobesBase + Math.round(In * 6 + Tn * 3);
  const spikiness = 0.15 + Tn*0.9;
  const wobbleAmp = 0.05 + In*0.25;
  const asymX = V * 0.6;
  const asymY = currentEmotion.sorrow * 0.7;
  const breathing = Math.sin(time*1.1) * (0.04 + E*0.12);

  // 색 팔레트 설정
  // 기본 hue: 210~260 (청록~보라 사이)
  let baseHue = 230 + 25*V + 15*Tn;      // valence/분노에 따라 약간 이동
  const coreSat = 25 + 35*E + 20*In;     // 에너지/놀람 많을수록 더 선명
  const edgeSat = coreSat * 0.6;
  const coreLight = 60 - 10*Tn - 5*In;   // 분노/놀람 많을수록 조금 어두움
  const edgeLight = 5 + 10*E;

  ectx.save();
  ectx.translate(cx, cy);

  const rot = analyzing ? time*1.8 : time*0.4;
  ectx.rotate(rot);

  // --- 메인 외곽 형상 ---
  ectx.beginPath();
  const steps = 260;
  for (let i = 0; i <= steps; i++) {
    const ratio = i / steps;
    const theta = ratio * Math.PI*2;

    const lobeTerm = Math.cos(lobes*theta + baseSeed*0.3);
    const wobble = Math.sin(theta*2 + time*1.3 + baseSeed) * wobbleAmp;

    const nx = Math.cos(theta);
    const ny = Math.sin(theta);
    const n = n2(nx*0.8 + baseSeed, ny*0.8, time*0.4*(1+In));

    let r = baseR * (1 + spikiness*lobeTerm + wobble + breathing + n*0.25);

    const ax = 1 + asymX * Math.cos(theta);
    const ay = 1 + asymY * Math.sin(theta - Math.PI/2);

    const x = Math.cos(theta) * r * ax;
    const y = Math.sin(theta) * r * ay + asymY*baseR*0.4;

    if (i === 0) ectx.moveTo(x,y);
    else ectx.lineTo(x,y);
  }
  ectx.closePath();

  const coreColor = hslToRgba(baseHue, coreSat, coreLight, 0.9*Math.max(E,0.2));
  const edgeColor = hslToRgba(baseHue - 10, edgeSat, edgeLight, 0.0);

  const grad = ectx.createRadialGradient(0,0,baseR*0.15, 0,0,baseR*1.5);
  grad.addColorStop(0, coreColor);
  grad.addColorStop(1, edgeColor);

  ectx.fillStyle = grad;
  ectx.fill();

  // 윤곽선 (색은 거의 안드러나게, 살짝)
  ectx.lineWidth = 0.8 + 2.5*Tn;
  const strokeCol = hslToRgba(baseHue + 15, 20 + 30*Tn, 70 - 20*Tn, 0.18 + 0.25*Tn);
  ectx.strokeStyle = strokeCol;
  ectx.stroke();

  // --- 내부 레이어 (오일필름 느낌) ---
  ectx.globalAlpha = 0.55 + 0.25*E;
  ectx.beginPath();
  for (let i = 0; i <= steps; i++) {
    const ratio = i / steps;
    const theta = ratio * Math.PI*2;

    const lobeTerm = Math.cos((lobes+1)*theta + baseSeed*0.73);
    const wobble = Math.sin(theta*3 + time*0.9 + baseSeed*1.3) * wobbleAmp*0.6;
    const nx = Math.cos(theta+0.5);
    const ny = Math.sin(theta+0.5);
    const n = n2(nx*1.1 + baseSeed*1.9, ny*1.1, time*0.5*(1+In*0.8));

    let r = baseR*0.75 * (1 + spikiness*0.6*lobeTerm + wobble + n*0.35 + breathing*0.7);

    const ax = 1 + asymX*0.4 * Math.cos(theta+0.7);
    const ay = 1 + asymY*0.5 * Math.sin(theta);

    const x = Math.cos(theta) * r * ax;
    const y = Math.sin(theta) * r * ay + asymY*baseR*0.2;

    if (i === 0) ectx.moveTo(x,y);
    else ectx.lineTo(x,y);
  }
  ectx.closePath();

  // 내부는 hue를 살짝 틀어서 유막처럼
  const innerHue = baseHue + 18*In + 10*Tn;
  const innerSat = coreSat + 10*In;
  const innerLight = coreLight + 5*E;

  const innerGrad = ectx.createRadialGradient(0,0,baseR*0.1, 0,0,baseR*1.0);
  innerGrad.addColorStop(0, hslToRgba(innerHue, innerSat, innerLight, 0.35 + 0.35*E));
  innerGrad.addColorStop(1, hslToRgba(innerHue - 20, innerSat*0.6, edgeLight+5, 0.0));
  ectx.fillStyle = innerGrad;
  ectx.fill();

  ectx.restore();

  // 하단 텍스트/설명 없음 (완전 추상)
}

// 루프
function loop(ts) {
  if (!lastTime) lastTime = ts;
  const dt = ts - lastTime;
  lastTime = ts;

  drawAbstractInk(dt);
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

</script>
</body>
</html>




