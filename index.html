<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Deep Digital Aura</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; font-family: 'Pretendard', sans-serif; user-select: none; }
    
    #container { position: absolute; width: 100%; height: 100%; top: 0; left: 0; z-index: 0; }
    
    /* 화면 공통 */
    .screen {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      transition: opacity 0.5s ease;
      z-index: 10;
      pointer-events: none;
    }
    .screen.active { opacity: 1; pointer-events: auto; }
    .screen.hidden { opacity: 0; pointer-events: none; display: none; }

    /* UI 요소들 */
    button {
      padding: 16px 40px;
      border: 1px solid rgba(255, 255, 255, 0.4);
      background: rgba(0, 0, 0, 0.6);
      color: #fff; font-size: 16px; letter-spacing: 2px;
      cursor: pointer; border-radius: 50px;
      backdrop-filter: blur(5px);
      text-transform: uppercase;
    }
    button:active { transform: scale(0.95); }

    /* 대기 화면 */
    #start-screen { z-index: 30; background: #000; } 
    #startBtn { border: none; background: transparent; font-size: 22px; letter-spacing: 4px; animation: pulse 2s infinite; }
    @keyframes pulse { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }

    /* 카메라 화면 */
    #camera-screen { justify-content: flex-end; padding-bottom: 60px; background: rgba(0,0,0,0.3); }
    #camera-frame {
      position: absolute; top: 45%; left: 50%; transform: translate(-50%, -50%);
      width: 300px; height: 300px; 
      border: 1px solid rgba(255,255,255,0.3); background: #000; overflow: hidden;
    }
    #cam { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); opacity: 0.8; }
    #face-guide {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      width: 60%; height: 70%; border: 2px dashed rgba(255,255,255,0.5); border-radius: 50%;
    }
    
    /* 결과 화면 */
    #retry-screen { justify-content: flex-end; padding-bottom: 60px; }
    #info-text { position: absolute; top: 15%; width: 100%; text-align: center; color: rgba(255,255,255,0.7); }

    #snap { display: none; }
  </style>
</head>
<body>

<div id="container"></div>

<div id="start-screen" class="screen active">
  <button id="startBtn">TOUCH TO START</button>
  <div style="color:#555; font-size:10px; margin-top:10px;">카메라 및 센서 권한 필요</div>
</div>

<div id="camera-screen" class="screen hidden">
  <div id="camera-frame">
    <video id="cam" autoplay playsinline muted></video>
    <div id="face-guide"></div>
  </div>
  <button id="scanBtn">SCAN AURA</button>
</div>

<div id="retry-screen" class="screen hidden">
  <div id="info-text">분석 중...</div>
  <button id="retryBtn">↺ RE-SCAN</button>
</div>

<canvas id="snap"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/josephg/noisejs/perlin.js"></script>

<script>
// [서버 주소]
const SERVER_URL = "https://emotion-server-backend-907115489834.asia-northeast3.run.app/analyze";

const startScreen = document.getElementById("start-screen");
const cameraScreen = document.getElementById("camera-screen");
const retryScreen = document.getElementById("retry-screen");
const startBtn = document.getElementById("startBtn");
const scanBtn = document.getElementById("scanBtn");
const retryBtn = document.getElementById("retryBtn");
const infoText = document.getElementById("info-text");
const videoElement = document.getElementById("cam");

let stream = null;
let idleTimer = null;
const IDLE_LIMIT = 60000;

/* ================= [1] 데이터 수집 (화면엔 안보임) ================= */
let audioContext, analyser, microphone;
let audioVolume = 0; // 저장용 데이터
let deviceTilt = 90; // 저장용 데이터

// 1. 오디오 분석 (데이터 수집용)
function setupAudioAnalysis(stream) {
  if (!stream.getAudioTracks().length) return;
  
  audioContext = new (window.AudioContext || window.webkitAudioContext)();
  analyser = audioContext.createAnalyser();
  microphone = audioContext.createMediaStreamSource(stream);
  microphone.connect(analyser);
  analyser.fftSize = 256;
  
  const dataArray = new Uint8Array(analyser.frequencyBinCount);
  
  function measureVolume() {
    if (!audioContext) return;
    analyser.getByteFrequencyData(dataArray);
    let sum = 0;
    for(let i=0; i<dataArray.length; i++) sum += dataArray[i];
    audioVolume = sum / dataArray.length; // 0~255 사이 값
    requestAnimationFrame(measureVolume);
  }
  measureVolume();
}

// 2. 기기 기울기 (데이터 수집용)
function handleOrientation(event) {
  if (event.beta !== null) {
    deviceTilt = Math.abs(event.beta);
  }
}

// 3. 데이터 패키징 (서버 전송용)
function collectDeepData() {
  // 소음 상태 텍스트화
  let soundStatus = "Quiet";
  if (audioVolume > 10) soundStatus = "Moderate";
  if (audioVolume > 30) soundStatus = "Loud";

  // 자세 상태 텍스트화
  let posture = "Upright";
  if (deviceTilt < 20) posture = "Lying Down";
  
  return {
    // A. 소리 정보 (저장만 함)
    sound: {
      level: audioVolume.toFixed(1),
      status: soundStatus
    },
    // B. 자세 정보 (저장만 함)
    posture: {
      tilt_angle: deviceTilt.toFixed(1) + "°",
      status: posture
    },
    // C. 기기 정보
    device: {
      userAgent: navigator.userAgent,
      platform: navigator.platform
    },
    timestamp: new Date().toString()
  };
}


/* ================= [2] 시퀀스 로직 ================= */

// 시작 버튼: 권한 획득
startBtn.addEventListener("click", async () => {
  try {
    // audio: true (소리 데이터 수집을 위해 마이크 켬)
    stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "user" }, audio: true });
    videoElement.srcObject = stream;
    videoElement.play();
    
    // 오디오 분석 시작 (백그라운드에서 값만 읽음)
    setupAudioAnalysis(stream);

  } catch (e) { alert("카메라/마이크 권한이 필요합니다."); return; }

  // 아이폰용 센서 권한
  if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
    DeviceOrientationEvent.requestPermission()
      .then(response => {
        if (response === 'granted') window.addEventListener('deviceorientation', handleOrientation);
      })
      .catch(console.error);
  } else {
    window.addEventListener('deviceorientation', handleOrientation);
  }

  showScreen(cameraScreen);
  resetIdleTimer();
});

// 스캔 버튼
scanBtn.addEventListener("click", async () => {
  resetIdleTimer();
  showScreen(null);
  retryScreen.classList.remove("hidden"); retryScreen.classList.add("active");
  retryBtn.style.display = "none";
  infoText.textContent = "감정 에너지를 시각화합니다...";
  
  setAnalyzingState(true);

  const canvas = document.getElementById("snap");
  const ctx = canvas.getContext("2d");
  canvas.width = videoElement.videoWidth;
  canvas.height = videoElement.videoHeight;
  ctx.save(); ctx.scale(-1, 1);
  ctx.drawImage(videoElement, -canvas.width, 0, canvas.width, canvas.height);
  ctx.restore();

  // [중요] 딥 데이터 수집 (저장용)
  const deepData = collectDeepData();
  console.log("Saving Deep Data (Hidden):", deepData);

  canvas.toBlob(async blob => {
    const form = new FormData();
    form.append("frame", blob, "frame.jpg");
    // 메타데이터 전송 (JSON 파일에 저장됨)
    form.append("metadata", JSON.stringify(deepData));
    
    try {
      const res = await fetch(SERVER_URL, { method: "POST", body: form });
      if(!res.ok) throw new Error("Server Error");
      const data = await res.json();
      
      if (data.status === "ok") {
        infoText.textContent = ""; 
        updateAura(data);
      } else { infoText.textContent = "인식 실패"; }
    } catch (e) { console.error(e); infoText.textContent = "서버 연결 실패"; } 
    finally {
      setAnalyzingState(false);
      setTimeout(() => { retryBtn.style.display = "block"; }, 2000);
    }
  }, "image/jpeg", 0.9);
});

retryBtn.addEventListener("click", () => {
  resetIdleTimer();
  showScreen(cameraScreen);
  setBackgroundState();
  videoElement.play();
});

function resetIdleTimer() {
  if (idleTimer) clearTimeout(idleTimer);
  idleTimer = setTimeout(() => { location.reload(); }, IDLE_LIMIT);
}
function showScreen(target) {
  [startScreen, cameraScreen, retryScreen].forEach(s => { s.classList.remove("active"); s.classList.add("hidden"); });
  if (target) { target.classList.remove("hidden"); target.classList.add("active"); }
}


/* ================= [3] Three.js 시각화 (안정된 버전) ================= */
// 여기서는 소리나 기울기 값을 시각화에 쓰지 않습니다 (요청사항 반영)
let scene, camera, renderer, points;
const PARTICLE_COUNT = 6000;
let particlesData = []; 
let currentEmotions = { joy: 0, sorrow: 0, anger: 0, surprise: 0 };
let isActive = false; let time = 0;
let targetOpacity = 0.0; let targetSpeed = 1.0;
noise.seed(Math.random());

function initThree() {
  const container = document.getElementById("container");
  scene = new THREE.Scene(); scene.background = new THREE.Color(0x000000); 
  camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
  camera.position.z = 300; 
  renderer = new THREE.WebGLRenderer({ alpha: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  container.appendChild(renderer.domElement);

  const posArray = new Float32Array(PARTICLE_COUNT * 3);
  const colorArray = new Float32Array(PARTICLE_COUNT * 3);

  for(let i=0; i<PARTICLE_COUNT; i++) {
    posArray[i*3] = 0; posArray[i*3+1] = -1000; posArray[i*3+2] = 0;
    particlesData.push({ vx: 0, vy: 0, vz: 0, life: Math.random(), maxLife: 0.5 + Math.random(), seed: Math.random()*100 });
    colorArray[i*3] = 1; colorArray[i*3+1] = 1; colorArray[i*3+2] = 1;
  }
  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
  geo.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));
  const mat = new THREE.PointsMaterial({ size: 4.0, vertexColors: true, transparent: true, opacity: 0, blending: THREE.AdditiveBlending, depthWrite: false });
  points = new THREE.Points(geo, mat);
  scene.add(points);
}

function resetParticle(idx, positions) {
  const i3 = idx * 3;
  if (targetOpacity > 0.1) { 
    const spread = 20; 
    positions[i3] = (Math.random() - 0.5) * spread;
    positions[i3+1] = -80 + (Math.random() - 0.5) * spread;
    positions[i3+2] = (Math.random() - 0.5) * spread;
  } else { positions[i3] = 0; positions[i3+1] = -1000; positions[i3+2] = 0; }
  if (particlesData[idx]) { particlesData[idx].life = 0; particlesData[idx].vx = 0; particlesData[idx].vy = 0; }
}

function updateAura(data) {
  if (!data.emotions) return;
  currentEmotions = data.emotions;
  isActive = true; targetOpacity = 1.0; targetSpeed = 1.0;
}
function setAnalyzingState(isAnalyzing) { if(isAnalyzing) { targetOpacity = 0.5; targetSpeed = 3.0; } }
function setBackgroundState() { targetOpacity = 0.3; targetSpeed = 0.5; }

function animate() {
  requestAnimationFrame(animate);
  const positions = points.geometry.attributes.position.array;
  const colors = points.geometry.attributes.color.array;
  const { joy, sorrow, anger, surprise } = currentEmotions;
  time += 0.008; 
  points.material.opacity += (targetOpacity - points.material.opacity) * 0.05;

  let tr=0.5, tg=0.5, tb=0.8; let upwardForce=0.3; let turbulence=0.5; let spread=1.0;           
  if (isActive) {
    if (joy>0.1) { tr=1.0; tg=0.9; tb=0.2; upwardForce=1.0+joy; turbulence=1.0; spread=2.0; }
    if (anger>0.1) { tr=1.0; tg=0.1; tb=0.1; upwardForce=0.5; turbulence=4.0; spread=3.0; }
    if (sorrow>0.1) { tr=0.1; tg=0.3; tb=0.9; upwardForce=0.1; turbulence=0.2; spread=0.5; }
    if (surprise>0.1) { tr=1.0; tg=1.0; tb=1.0; upwardForce=1.5; spread=4.0; }
  }

  // [시각화 로직: 소리/자세 반영 X]
  // 오직 감정(joy, sorrow 등)에 의해서만 움직임이 결정됨
  for (let i = 0; i < PARTICLE_COUNT; i++) {
    if (points.material.opacity < 0.01) continue;
    const p = particlesData[i]; const idx = i * 3;
    p.life += 0.01 * targetSpeed;
    if (p.life > p.maxLife) resetParticle(i, positions);

    let cx = positions[idx]; let cy = positions[idx+1];
    const nX = noise.simplex3(cx * 0.008, cy * 0.008, time + p.seed);
    const nY = noise.simplex3(cx * 0.008, cy * 0.008 + 100, time + p.seed);
    
    // 순수 감정 기반 움직임
    p.vx += nX * turbulence * 0.05; 
    p.vy += upwardForce * 0.05; 
    p.vx += (cx * 0.001) * spread; 

    p.vx *= 0.95; p.vy *= 0.95; p.vz *= 0.95;
    positions[idx] += p.vx * targetSpeed; positions[idx+1] += p.vy * targetSpeed; positions[idx+2] += p.vz * targetSpeed;

    const opacity = Math.sin(p.life / p.maxLife * Math.PI); 
    colors[idx] += (tr - colors[idx]) * 0.05; colors[idx+1] += (tg - colors[idx+1]) * 0.05; colors[idx+2] += (tb - colors[idx+2]) * 0.05;
    colors[idx] = Math.max(0, colors[idx] * opacity); colors[idx+1] = Math.max(0, colors[idx+1] * opacity); colors[idx+2] = Math.max(0, colors[idx+2] * opacity);
  }
  points.geometry.attributes.position.needsUpdate = true;
  points.geometry.attributes.color.needsUpdate = true;
  renderer.render(scene, camera);
}
initThree(); animate();
</script>
</body>
</html>
